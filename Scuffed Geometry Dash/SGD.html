<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Scuffed Geometry Dash</title>
        <style>
            body {
                background-color: white;
                overflow: hidden;
            }
            .center {
                position: relative;
                top: 40%;
                left: 50%;
                -ms-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            .menu {
                text-align: center;
                background-color: rgba(255, 255, 255, 0);
                color: rgb(255, 255, 255);
                border: 0px
            }
            button[class~="menu"]:hover{
                text-decoration: overline underline white double 1px;
            }
            button[class~="selected"]{
                text-decoration: overline underline white double 1px;
            }
            .menuGroup {
                position:fixed;
                height: 100vh;
                width: 100vw;
                top: 0px;
                left: 0px;
                background-color: rgba(0, 0, 0, 0.5);
                color:rgb(255, 255, 255);
                opacity: 1;
                margin: 0px;
                padding: 0px;
                border: 0px;
                z-index: 10;
            }
            #controls {
                position:fixed;
                height: 100vh;
                width: 100vw;
                top: 0px;
                left: 0px;
                background-color: rgba(255, 255, 255, 0);
                color:rgba(0, 0, 0, 1);
                opacity: 0;
                z-index: 5;
                margin: 0px;
                padding: 0px;
                border: 0px;
                pointer-events:stroke;
                cursor:default;
            }
            #player {
                position: absolute;
                height: 30px;
                width: 30px;
                bottom: 10px;
                left: -100px;
                background-color: rgb(108, 108, 108);
            }

            .platform {
                position: absolute;
                background-color: rgba(0, 0, 0, .5);
            }
            .damaging {
                position: absolute;
                background-color: rgba(255, 0, 0, 0.5);
            }

            #origin{position: absolute; background-color: rgba(0, 0, 0, .5); bottom: 0px; left: 0px; height: 0px; width: 0px}
            #deathPlane{bottom: 0px; left: 0px; height: 5px; width: 20000px;}
            #floor{bottom: 0px; left: -100px; height: 5px; width: 4000px;}
            #roof{bottom: 100%; left: -100px; height: 5px; width: 4000px;}
            
        </style>
        <script>
            //Setup
            const sleep = (sleep) => new Promise((resolve) => setTimeout(resolve, sleep))
            function getOffset(elem) {
                const rect = document.getElementById(elem).getBoundingClientRect();
                return {
                    top: winHeight-rect.top,
                    left: rect.left,
                    right: rect.right, 
                    bottom: winHeight-rect.bottom,
                    height: rect.height,
                    width: rect.width
                }
            }

            function round(value, n=0, d="round"){
                if (d == "round"){
                    return Math.round(value*10**n)/10**n
                } else if (d == "down"){
                    return Math.floor(value*10**n)/10**n
                } else if (d == "up"){
                    return Math.ceil(value*10**n)/10**n
                } else if (d == "none"){
                    return Number(String(value*10**n).split(".")[0])/10**n
                }
            }

            function pageLoad(){
                playerSetup()
                globalSetup()
                collisionDetect()
                if (mode=="dino" || mode=="flappy"){cactusGenerator()}
                gameLoop()
                controlLoop()
                debug()
            }

            function globalSetup(){
                //Global
                winHeight = window.innerHeight, winWidth = window.innerWidth;
                gameSpd = 25, gravity = 1.5;
                globalTime = 0, ingameTime = 0, isPaused = false;
                player = "player";
                rawInputs = [];
                panSpeedX = 50, panSpeedY = 32;
                selectedMenuButton = "", menuOpen = false;
                startTime = new Date()
                obstacleSpawn = mode=="dino" || mode=="flappy";
                document.getElementById("roof").style.bottom = `${window.innerHeight}px`;
            }

            function playerSetup(){
                //Player
                onground = true;
                gravityEnabled = true;
                facingX = "right";
                canJump = true;
                moveSpd = 5, jumpSpd = 16, gravityCap = -jumpSpd;
                spdCap = moveSpd;
                momentum = {"x":8, "y":0};
                playerHealth = 5;
                spawnPoint = {"x":50, "y":5}
                mode = "normal"; //normal, ship, dino, flappy
                //block height=30px, width=30px
            }

            function updateWindowSize(){
                if (winHeight != window.innerHeight){
                    winHeight = window.innerHeight;
                }
                if (winWidth != window.innerWidth){
                    winWidth = window.innerWidth;
                }
            }

            //Game Stuff
            async function gameLoop(){
                while(true){
                    await sleep(gameSpd)
                    externalTimeLoops()
                    updateWindowSize()
                    controlLoop()
                    if (isPaused == false){
                        checkState()
                        timeLoops()
                        moveObstacles()
                        screenPanning()
                        gravityLoop()
                        collisionDetect()
                        moveMomentum()
                        checkDamage()
                        checkState()
                    }
                }
            }

            function externalTimeLoops(){
                globalTime = round(globalTime + 0.025, 3)
            }

            function timeLoops(){
                ingameTime = round(ingameTime + 0.025, 3);
            }

            function gravityLoop(){
                if (gravityEnabled == true){
                    let dist = round(getOffset(player).bottom);
                    if (dist > ground[0] || isNaN(ground[0])==true){
                        momentum["y"] = Math.max(gravityCap, momentum["y"]-gravity);
                    }
                }
            }

            function checkState(){
                let bottom = round(getOffset(player).bottom);
                if (bottom <= ground[0]){
                    onground = true;
                } else {
                    onground = false;
                }
                if (onground == true){
                    canJump = true;
                } else {
                    canJump = false;
                }
            }

            async function movementBuffer(event, mode){
                let key = event.key.toLowerCase()
                if (event.repeat == false){
                    if (mode == true){
                        if (rawInputs.includes(key) == false){
                            rawInputs.push(key);
                        }
                    } else {
                        if (rawInputs.includes(key) == true){
                            rawInputs.splice(rawInputs.indexOf(key), 1);
                        }
                    }
                }
            }

            async function controlLoop(){
                let inputs = [...rawInputs]
                if (inputs.includes("a") && inputs.includes("d")){
                    if (inputs.indexOf("d") > inputs.indexOf("a")){
                        inputs.splice(inputs.indexOf("d"))
                    } else if (inputs.indexOf("a") > inputs.indexOf("d")){
                        inputs.splice(inputs.indexOf("a"))
                    }
                }
                for (let i in inputs){
                    key = inputs[i];
                    switch (key){
                        default:
                            break;
                        case "alt":
                            rawInputs = [];
                            break;
                        case "tab":
                            rawInputs = [];
                            break;
                        case "t":
                            screenPanning();
                            break;
                        case "l":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            step()
                            break;
                        case "escape":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (menuOpen == false && isPaused == false){
                                isPaused = true;
                            }
                            selectedMenuButton = "";
                            menuManager()
                            break;
                        case "w":
                            if (menuOpen == true){
                                rawInputs.splice(rawInputs.indexOf(key,1))
                                menuSelect("up")
                            }
                            break;
                        case "s":
                            if (menuOpen == true){
                                rawInputs.splice(rawInputs.indexOf(key,1))
                                menuSelect("down")
                            }
                            break;
                        case "a":
                            break;
                        case "d":
                            break;
                        case " ":
                            if (mode=="normal" || mode=="dino"){
                                if (canJump == true){
                                    momentum["y"] = jumpSpd;
                                }
                            } else if (mode=="ship" || mode=="flappy") {
                                momentum["y"] = Math.min(-gravityCap, momentum["y"]+gravity*2);;
                            }
                            break;
                        case "enter":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (menuOpen == true){
                                click()
                            }
                            break;
                    }
                }
            }

            function moveMomentum(){
                let x = momentum["x"], y = momentum["y"];
                let left = round(getOffset(player).left), bottom = round(getOffset(player).bottom), right = round(getOffset(player).right), top = round(getOffset(player).top);
                if (x > 0 && y > 0){
                    if (right + x >= cornerX[0] && top + y >= cornerY[0]){
                        if (cornerY[0]-top>cornerX[0]-right){
                            a=1//momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x < 0 && y > 0){
                    if (left + x <= cornerX[0] && top + y >= cornerY[0]){
                        if (cornerY[0]-top>left-cornerX[0]){
                            a=1//momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x > 0 && y < 0){
                    if (right + x >= cornerX[0] && bottom + y <= cornerY[0]){
                        if (bottom-cornerY[0]>cornerX[0]-right){
                            a=1//momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x < 0 && y < 0){
                    if (left + x <= cornerX[0] && bottom + y <= cornerY[0]){
                        if (bottom-cornerY[0]>left-cornerX[0]){
                            a=1//momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                }
                x = momentum["x"], y = momentum["y"];
                if (x > 0){
                    facingX = "right";
                    let newDist = left + x;
                    if (newDist >= wallR[0] - getOffset(player).width){
                        newDist =  round(wallR[0] - getOffset(player).width - 0.00001,3);
                        document.getElementById(player).style.left = `${newDist}px`;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.left = `${newDist}px`;
                } else if (x < 0){
                    facingX = "left";
                    let newDist = left + x;
                    if (newDist <= wallL[0]){
                        newDist = round(wallL[0] + 0.00001,3);
                        document.getElementById(player).style.left = `${newDist}px`;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.left = `${newDist}px`;
                }
                if (y > 0){
                    let newDist = bottom + y;
                    if (newDist >= ceiling[0] - getOffset(player).height){
                        newDist = ceiling[0] - getOffset(player).height;
                        momentum["y"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.bottom = `${newDist}px`;
                    
                } else if (y < 0){
                    let newDist = bottom + y;
                    if (newDist <= ground[0]){
                        newDist = ground[0];
                        momentum["y"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.bottom = `${newDist}px`;
                }
            }
            
            function collisionDetect(){
                platforms = document.querySelectorAll(".platform");
                damaging = document.querySelectorAll(".damaging");
                let topP = round(getOffset(player).top), bottomP = round(getOffset(player).bottom), leftP = round(getOffset(player).left), rightP = round(getOffset(player).right);
                groundCollision = {}, ceilingCollision = {}, wallLCollision = {}, wallRCollision = {};
                //obtain planes from div
                for (let i of platforms){
                    let focus = i.id, bottom = getOffset(focus).bottom, top = getOffset(focus).top, left = getOffset(focus).left, right = getOffset(focus).right;
                    groundCollision[focus] = {"y":top, "x1":left, "x2":right, "id":focus};
                    ceilingCollision[focus] = {"y":bottom, "x1":left, "x2":right, "id":focus};
                    wallLCollision[focus] = {"x":right, "y1":bottom, "y2":top, "id":focus};
                    wallRCollision[focus] = {"x":left, "y1":bottom, "y2":top, "id":focus};
                }
                let damageEntity = []
                for (let i of damaging){
                    damageEntity.push(i.id)
                }

                let valid = [];
                for (let i in wallRCollision){
                    i = wallRCollision[i];
                    let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                    if (rightP <= x && topP > y1 && bottomP < y2){
                        if (damageEntity.includes(id)==true){
                            valid.push([x, "dmg"]);
                        } else {
                            valid.push([x, "none"]);
                        }
                    }
                }
                wallR = valid.sort((a,b) => {return a[0]-b[0]})[0]
                if (wallR == undefined){wallR = [NaN, "none"];}
                
                valid = [];
                for (let i in wallLCollision){
                    i = wallLCollision[i];
                    let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                    if (leftP >= x && topP > y1 && bottomP < y2){
                        if (damageEntity.includes(id)==true){
                            valid.push([x, "dmg"]);
                        } else {
                            valid.push([x, "none"]);
                        }
                    }
                }
                wallL = valid.sort((a,b) => {return b[0]-a[0]})[0]
                if (wallL == undefined){wallL = [NaN, "none"];}
                
                valid = [];
                for (let i in ceilingCollision){
                    i = ceilingCollision[i];
                    let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                    if (topP <= y && rightP > x1 && leftP < x2){
                        if (damageEntity.includes(id)==true){
                            valid.push([y, "dmg"]);
                        } else {
                            valid.push([y, "none"]);
                        }
                    }
                }
                ceiling = valid.sort((a,b) => {return a[0]-b[0]})[0]
                if (ceiling == undefined){ceiling = [NaN, "none"];}
                
                valid = [];
                for (let i in groundCollision){
                    i = groundCollision[i]
                    let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                    if (bottomP >= y && rightP > x1 && leftP < x2){
                        if (damageEntity.includes(id)==true){
                            valid.push([y, "dmg"]);
                        } else {
                            valid.push([y, "none"]);
                        }
                    }
                }
                ground = valid.sort((a,b) => {return b[0]-a[0]})[0]
                if (ground == undefined){ground = [NaN, "none"];}

                let x = momentum["x"], y = momentum["y"]
                if (x!=0 && y!= 0){
                    let newTopP = topP + momentum["y"];
                    let newBottomP = bottomP + momentum["y"];
                    let newLeftP = leftP + momentum["x"];
                    let newRightP = rightP + momentum["x"];
                    let valid = []
                    if (x > 0 && y > 0){
                        for (let i in wallRCollision){
                            i = wallRCollision[i];
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                            if (rightP <= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in ceilingCollision){
                            i = ceilingCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (topP <= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x < 0 && y > 0){
                        for (let i in wallLCollision){
                            i = wallLCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (leftP >= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in ceilingCollision){
                            i = ceilingCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (topP <= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x > 0 && y < 0){
                        for (let i in wallRCollision){
                            i = wallRCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (rightP <= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in groundCollision){
                            i = groundCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (bottomP >= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x < 0 && y < 0){
                        for (let i in wallLCollision){
                            i = wallLCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (leftP >= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in groundCollision){
                            i = groundCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (bottomP >= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    }
                }
            }

            function screenPanning(){
                let screenCenterX = Number()
                if (facingX=="right"){
                    screenCenterX = round(winWidth*0.15)
                } else {
                    screenCenterX = round(winWidth*0.85)
                }
                let screenCenterY = round(winHeight*0.5);
                let playerCenterX = round(round(getOffset(player).left) + getOffset(player).width/2,1), playerCenterY = round(getOffset(player).bottom);
                let elements = document.getElementById("gameArea").querySelectorAll("div");
                let origin = {"x":getOffset("origin").left, "y":getOffset("origin").bottom};
                let limit = {"x":Infinity, "y":getOffset("roof").bottom}
                if (screenCenterX != playerCenterX){
                    panDistX = Math.sign(screenCenterX-playerCenterX)*round(panSpeedX*Math.log2(Math.abs(screenCenterX-playerCenterX)/(winWidth/4)+1),3);
                    let newPos = round(getOffset(player).left+panDistX);
                    document.getElementById(player).style.left = `${newPos}px`;
                }
                
                if (screenCenterY != playerCenterY){
                    let panDistY = Math.sign(screenCenterY-playerCenterY)*round(panSpeedY*Math.log2(Math.abs(screenCenterY-playerCenterY)/screenCenterY+1),3);
                    if (origin["y"]+panDistY > 0){
                        panDistY = 0-origin["y"];
                    } else if (limit["y"]+panDistY < winHeight){
                        panDistY = winHeight-limit["y"];
                    }
                    for (let i=0; i<elements.length; i++){
                        let target = elements[i].id;
                        let newPos = round(getOffset(target).bottom+panDistY);
                        if (Math.abs(panDistY)<0.5 && Math.abs(panDistY)>0.05){
                            newPos = getOffset(target).bottom+Math.sign(screenCenterY-playerCenterY);
                        }
                        document.getElementById(target).style.bottom = `${newPos}px`;
                    }
                }
            }

            function checkDamage(){
                let top = round(getOffset(player).top), bottom = round(getOffset(player).bottom), left = round(getOffset(player).left), right = round(getOffset(player).right);
                if (top == ceiling[0] && ceiling[1] == "dmg"){
                    damage(player, Infinity)
                }
                if (bottom == ground[0] && ground[1] == "dmg"){
                    damage(player, Infinity)
                }
                if (left == wallL[0]){
                    damage(player, Infinity)
                }
                if (right == wallR[0]){
                    damage(player, Infinity)
                }
            }

            async function damage(target, amount){
                momentum["x"] = 0
                await sleep(200)
                if (target == player){
                    playerHealth -= amount;
                    if (playerHealth <= 0){
                        killPlayer()
                    }
                }
            }

            function killPlayer(){
                if (mode=="dino" || mode=="flappy"){
                    obstacleSpawn = false;
                    for (let i of platforms){
                        let id = i.id
                        if (id.substr(0,4)=="plat"){
                            document.getElementById(id).remove()
                        }
                    }
                }
                let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                document.getElementById(player).style.left = `${originX+spawnPoint["x"]}px`;
                document.getElementById(player).style.bottom = `${originY+spawnPoint["y"]}px`;
                playerSetup()
                for (let i=0; i<1000; i++){
                    screenPanning()
                }
                if (mode=="dino" || mode=="flappy"){
                    obstacleSpawn = true;
                }
            }

            function moveObstacles(){
                let elements = document.getElementById("gameArea").querySelectorAll(".platform");
                for (let i of elements){
                    if (i.id.substr(0,4)=="plat"){
                        if (facingX=="right" && getOffset(i.id).right < -100){
                            document.getElementById(i.id).remove()
                            continue
                        } else if (facingX=="left" && getOffset(i.id).left < winWidth+100){
                            document.getElementById(i.id).remove()
                            continue
                        }
                        document.getElementById(i.id).style.left = `${getOffset(i.id).left-momentum["x"]}px`;
                    }
                }
            }

            async function cactusGenerator(){
                while (true){
                    let delay = 0
                    if (mode=="dino"){
                        delay = (Math.random()+.3)*2;
                        momentum["x"] = round(ingameTime/20,0,"down")*2+8;
                    } else if (mode=="flappy"){
                        delay = 1.2;
                    }
                    let start = ingameTime
                    while (ingameTime-start < delay){
                        await sleep(1)
                    }

                    if (obstacleSpawn == true && mode=="dino"){
                        let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                        createPlatform([[(winWidth-getOffset(player).right)+(getOffset(player).left-originX), 5],[(winWidth-getOffset(player).right)+(getOffset(player).left-originX)+30, 35]], "damaging")
                    } else if (obstacleSpawn == true && mode=="flappy"){
                        let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                        let limit = {"top":getOffset("roof").bottom, "bottom":getOffset("floor").top}
                        let gap = 150;
                        let gapPos = Math.max(100, Math.floor(Math.random()*(limit["top"]-100-gap)))
                        createPlatform([[(winWidth-getOffset(player).right)+(getOffset(player).left-originX)+momentum["x"], 0],[(winWidth-getOffset(player).right)+(getOffset(player).left-originX)+30+momentum["x"], gapPos]], "damaging")
                        await sleep(25)
                        createPlatform([[(winWidth-getOffset(player).right)+(getOffset(player).left-originX), gapPos+gap],[(winWidth-getOffset(player).right)+(getOffset(player).left-originX)+30, limit["top"]]], "damaging")
                    } else {
                        ingameTime = 0;
                    }
                }
            }

            async function createPlatform(points, modifier){
                let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                
                if (points.length==2){
                    let platNum = 0
                    for (let i=0; i<platforms.length; i++){
                        if (platforms[i].id.substr(0,4) == "plat"){
                            platNum = Number(platforms[i].id.substr(4))+1;
                        }
                    }
                    document.getElementById("gameArea").innerHTML += `<div id="plat${platNum}" class="platform ${modifier}"></div>`;
                    let selected = document.getElementById(`plat${platNum}`);
                    let width = Math.abs(points[0][0] - points[1][0]);
                    let height = Math.abs(points[0][1] - points[1][1]);
                    let x1 = NaN, y1 = NaN;
                    for (let i of points){
                        if (isNaN(x1)==true){
                            x1 = i[0];
                        } else if (i[0] < x1){
                            x1 = i[0];
                        }
                        if (isNaN(y1)==true){
                            y1 = i[1];
                        } else if (i[1] < y1){
                            y1 = i[1];
                        }
                    }
                    selected.style.left = `${originX+x1}px`;
                    selected.style.bottom = `${originY+y1}px`;
                    selected.style.width = `${width}px`;
                    selected.style.height = `${height}px`;
                } else if (points.length == 4){

                } else {
                    console.log("Not implemented yet")
                }
            }

            //Debug
            async function step(n=1){
                isPaused = false;
                await sleep(25*n)//gameSpd
                isPaused = true;
            }

            async function debug(){
                while (true){
                    await sleep(1)
                    updateDisplay()
                }
            }

            function updateDisplay(){
                document.getElementById("realTime").innerHTML = "realTime: " + (new Date() - startTime)/1000;
                document.getElementById("globalTime").innerHTML = "globalTime: " + globalTime;
                document.getElementById("ingameTime").innerHTML = "ingameTime: " + ingameTime;
                document.getElementById("isPaused").innerHTML = "isPaused: " + isPaused;
                document.getElementById("gameSpd").innerHTML = "gameSpd: " + gameSpd;
                document.getElementById("momentum").innerHTML = `x: ${momentum["x"]} y: ${momentum["y"]}`;
                document.getElementById("onGround").innerHTML = "onGround: " + onground;
                //document.getElementById("facingX").innerHTML = "facingX: " + facingX;
                //document.getElementById("left").innerHTML = "Left: " + getOffset(player).left+ ", "+ wallL;
                //document.getElementById("right").innerHTML = "Right: " + getOffset(player).right+ ", "+ wallR;
                //document.getElementById("top").innerHTML = "Top: " + getOffset(player).top+ ", "+ ceiling;
                //document.getElementById("bottom").innerHTML = "Bottom: " + getOffset(player).bottom+ ", "+ ground;
                document.getElementById("mode").innerHTML = "Mode: " + mode;
                document.getElementById("rawInputs").innerHTML = "Inputs: " + [rawInputs];
            }

            function test(){
                let li = [];
                for (let i=10; i>0; i-=2){
                    let a = []
                    a.push(i, i-1)
                    li.push(a)
                }
                console.log(li.sort((a,b)=> {console.log(a[0],b[0]);return a[0]-b[0]}))
            }

            //Menus
            function focusControls(){
                //console.log(new Error().stack)
                document.getElementById("controls").focus();
            }

            async function menuManager(id=""){
                if (menuOpen == false){
                    menuOpen = true;
                    switchMenus("pauseMenu")
                    menuSelect()
                } else {
                    let current = ""
                    for (let i of document.getElementsByClassName("menuGroup")){
                        if (i.hidden == false){
                            current = i.id;
                            break;
                        }
                    }
                    if (id == ""){
                        if (current == "pauseMenu"){
                            isPaused = false;
                            menuOpen = false;
                            document.getElementById("pauseMenu").hidden = true;
                        } else {
                            switch (current){
                                default:
                                    break;
                                case "optionsMenu":
                                    switchMenus("pauseMenu")
                                    break;
                            }
                        }
                    } else {
                        switch (id){
                            default:
                                break;
                            case "optionsBack":
                                switchMenus("pauseMenu")
                                break;
                            case "options":
                                switchMenus("optionsMenu")
                                break;
                        }
                    }
                    menuSelect()
                }
            }

            function switchMenus(menu){
                selectedMenuButton = "";
                for (let i of document.getElementsByClassName("menuGroup")){
                    toggleMenu(i.id, true);
                }
                toggleMenu(menu, false);
            }

            function menuSelect(direction){
                let buttons = [];
                for (let i of document.getElementsByClassName("menu")){
                    if (i.tagName == "BUTTON"){
                        let cl = [...document.getElementById(i.id).classList];
                        if (cl.includes("selected")){
                            cl.splice(cl.indexOf("selected"), 1)
                            document.getElementById(i.id).classList = cl.toString().replace(",", " ");
                        }
                        if (document.getElementById(i.id).parentElement.hidden == false){
                            buttons.push(i.id)
                        }
                    }
                }
                if (buttons.length > 0){
                    if (selectedMenuButton == ""){
                        selectedMenuButton = buttons[0];
                    } else {
                        if (direction == "up"){
                            let index = buttons.indexOf(selectedMenuButton)-1
                            if (index < 0){
                                index = buttons.length-1;
                            }
                            selectedMenuButton = buttons[index]
                        } else {
                            let index = buttons.indexOf(selectedMenuButton)+1
                            if (index > buttons.length-1){
                                index = 0;
                            }
                            selectedMenuButton = buttons[index]
                        }
                    }
                    document.getElementById(selectedMenuButton).classList = [document.getElementById(selectedMenuButton).classList + " selected"]
                }
            }

            function click(){
                if (selectedMenuButton != ""){
                    document.getElementById(selectedMenuButton).onclick();
                    for (let i of document.getElementsByClassName("menu")){
                        if (i.tagName == "BUTTON" && i.id != selectedMenuButton){
                            let cl = [...document.getElementById(i.id).classList];
                            if (cl.includes("selected")){
                                cl.splice(cl.indexOf("selected"), 1)
                                document.getElementById(i.id).classList = cl.toString().replace(",", " ");
                            }
                        }
                    }
                }
            }

            function toggleMenu(id, pref=""){
                if (id == ""){return}
                if (pref == ""){
                    if (document.getElementById(id).hidden == true){
                        document.getElementById(id).hidden = false;
                    } else {
                        document.getElementById(id).hidden = true;
                    }
                } else {
                    document.getElementById(id).hidden = pref;
                }
            }

            function scrollMenu(menu){
                
            }

        </script>
    </head>
    <body onload="pageLoad()" onblur="if(isPaused==false){rawInputs.push('escape')}">
        <div id="debug">
            <label id="realTime"></label><br>
            <label id="globalTime"></label><br>
            <label id="ingameTime"></label><br>
            <label id="isPaused"></label><br>
            <label id="gameSpd"></label><br>
            <label id="momentum"></label><br>
            <label id="onGround"></label><br>
            <!--<label id="facingX"></label><br>
            <label id="left"></label><br>
            <label id="right"></label><br>
            <label id="top"></label><br>
            <label id="bottom"></label><br>-->
            <label id="mode"></label><br>
            <label id="rawInputs"></label><br>
        </div>
        <div id="gameArea">
            <input id="controls" autofocus onkeydown="movementBuffer(event, true)" onkeyup="movementBuffer(event, false)" onblur="focusControls()">
            <div id="origin"></div>
            <div id="player"></div>
            <div id="floor" class="platform"></div>
            <div id="roof" class="platform"></div>
        </div>
        <div id="pauseMenu" class="menuGroup" hidden>
            <h1 class="menu center">Paused</h1>
            <button id="resume" class="menu center" onclick="menuManager()">Resume</button><br><br>
            <button id="options" class="menu center" onclick="menuManager(id)">Options</button><br><br>
            <button id="quit" class="menu center" onclick="alert('No quitting!')">Save & Quit</button>
        </div>
        <div id="optionsMenu" class="menuGroup" hidden parent="pauseMenu">
            <h1 class="menu center">Options</h1>
            <button id="debugToggle" class="menu center" onclick="toggleMenu('debug')">Toggle Debug</button><br><br>
            <button id="temp2" class="menu center" onclick="focusControls()">Temp</button><br><br>
            <button id="optionsBack" class="menu center" onclick="menuManager(id)">Back</button>
        </div>
    </body>
</html>