<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Physics Engine</title>
        <style>
            body {
                background-color: white;
                overflow: hidden;
            }
            .center {
                position: relative;
                top: 40%;
                left: 50%;
                -ms-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            .menu {
                text-align: center;
                background-color: rgba(255, 255, 255, 0);
                color: rgb(255, 255, 255);
                border: 0px
            }
            button[class~="menu"]:hover{
                text-decoration: overline underline white double 1px;
            }
            button[class~="selected"]{
                text-decoration: overline underline white double 1px;
            }
            .menuGroup {
                position:fixed;
                height: 100vh;
                width: 100vw;
                top: 0px;
                left: 0px;
                background-color: rgba(0, 0, 0, 0.5);
                color:rgb(255, 255, 255);
                opacity: 1;
                margin: 0px;
                padding: 0px;
                border: 0px;
                z-index: 10;
            }
            #controls {
                position:fixed;
                height: 100vh;
                width: 100vw;
                top: 0px;
                left: 0px;
                background-color: rgba(255, 255, 255, 0);
                color:rgba(0, 0, 0, 1);
                opacity: 0;
                z-index: 5;
                margin: 0px;
                padding: 0px;
                border: 0px;
                pointer-events:stroke;
                cursor:default;
            }
            #player {
                position: absolute;
                height: 25px;
                width: 25px;
                bottom: 50px;
                left: 400px;
                background-color: rgb(108, 108, 108);
            }

            .platform {
                position: absolute;
                background-color: rgba(0, 0, 0, .5);
            }
            .damaging {
                position: absolute;
                background-color: rgba(255, 0, 0, 0.5);
            }

            #origin{position: absolute; background-color: rgba(0, 0, 0, .5); bottom: 0px; left: 0px; height: 0px; width: 0px}
            #deathPlane{bottom: 0px; left: -10000px; height: 5px; width: 20000px;}
            #floor{bottom: 5px; left: 0px; height: 5px; width: 3000px;}
            #wall{bottom: 0px; left: 5px; height: 2000px; width: 5px;}
            #plat1{bottom: 37px; left: 700px; height: 374px; width: 5px;}
            #plat2{bottom: 210px; left: 200px; height: 5px; width: 300px;}
            #plat3{bottom: 10px; left: 100px; height: 100px; width: 100px;}
            #plat4{bottom: 35px; left: 225px; height: 50px; width: 50px;}
            #plat5{bottom: 10px; left: 730px; height: 400px; width: 5px;}
            #plat6{bottom: 300px; left: 500px; height: 5px; width: 200px;}
            #plat7{bottom: 10px; left: 300px; height: 50px; width: 50px;}
            #plat8{bottom: 10px; left: 450px; height: 50px; width: 50px;}
            #plat9{bottom: 10px; left: 500px; height: 49px; width: 50px;}
            
        </style>
        <script>
            //Setup
            const sleep = (sleep) => new Promise((resolve) => setTimeout(resolve, sleep))
            function getOffset(elem) {
                const rect = document.getElementById(elem).getBoundingClientRect();
                return {
                    top: winHeight-rect.top,
                    left: rect.left,
                    right: rect.right, 
                    bottom: winHeight-rect.bottom,
                    height: rect.height,
                    width: rect.width
                }
            }

            function round(value, n=0, d="round"){
                if (d == "round"){
                    return Math.round(value*10**n)/10**n
                } else if (d == "down"){
                    return Math.floor(value*10**n)/10**n
                } else if (d == "up"){
                    return Math.ceil(value*10**n)/10**n
                } else if (d == "none"){
                    return Number(String(value*10**n).split(".")[0])/10**n
                }
            }

            function pageLoad(){
                globalSetup()
                playerSetup()
                collisionDetect()
                gameLoop()
                controlLoop()
                debug()
            }

            function globalSetup(){
                //Global
                winHeight = window.innerHeight, winWidth = window.innerWidth;
                gameSpd = 25, gravity = 10;
                globalTime = 0, ingameTime = 0, isPaused = false;
                player = "player";
                rawInputs = [];
                panSpeedX = 20, panSpeedY = 30;
                selectedMenuButton = "", menuOpen = false;
                startTime = new Date()
            }

            function playerSetup(){
                //Player
                onground = true, touchingWall = false, wallSlide = false
                gravityEnabled = true, dragEnabled = true
                facingX = "right", facingY = "neutral";
                dashCd = 0, canDash = true, isDashing = false, canJump = true;
                accelSpd = 2.5, moveSpd = 5, jumpSpd = 15, dashSpd = 20, gravityCap = -jumpSpd;
                spdCap = moveSpd, airDrag = 1, groundDrag = 1;
                gravTime = 0;
                momentum = {"x":0, "y":0};
                playerHealth = 5;
                spawnPoint = {"x":400, "y":230}
            }

            function updateWindowSize(){
                if (winHeight != window.innerHeight){
                    winHeight = window.innerHeight;
                }
                if (winWidth != window.innerWidth){
                    winWidth = window.innerWidth;
                }
            }

            //Game Stuff
             //Global
            async function gameLoop(){
                while(true){
                    await sleep(gameSpd)
                    externalTimeLoops()
                    updateWindowSize()
                    controlLoop()
                    if (isPaused == false){
                        checkState()
                        timeLoops()
                        screenPanning()
                        gravityLoop()
                        collisionDetect()
                        moveMomentum()
                        checkDamage()
                        checkState()
                    }
                }
            }

             //Global
            function externalTimeLoops(){
                globalTime = round(globalTime + 0.025, 3)
            }

             //Individual
            function timeLoops(){
                ingameTime = round(ingameTime + 0.025, 3);
                if (round(getOffset(player).bottom) > ground[0] || isNaN(ground[0])){
                    gravTime += 0.025;
                } else {
                    gravTime = 0;
                }
                if (dashCd > 0){
                    dashCd -= 0.025;
                } else {
                    dashCd = 0;
                }
            }

             //Individual
            function gravityLoop(){
                if (gravityEnabled == true){
                    let dist = round(getOffset(player).bottom);
                    if (dist > ground[0] || isNaN(ground[0])==true){
                        momentum["y"] = Math.max(gravityCap, round(momentum["y"]-gravity*gravTime,2));
                        /*
                        let newDist = dist - Math.min(gravityCap, gravity*gravTime);
                        newDist = round(newDist, 3);
                        if (newDist <= ground[0]){
                            newDist = ground[0];
                            onground = true;
                            momentum["y"] = 0;
                            let add = 0
                            if (round(getOffset(player).bottom) < -100){add=8}
                            document.getElementById(player).style.bottom = `${newDist+add}px`
                            gravTime = 0;
                        }*/
                    }
                }
            }

             //Individual
            function checkState(){
                let bottom = round(getOffset(player).bottom);
                if (bottom <= ground[0]){
                    onground = true;
                } else {
                    onground = false;
                }
                if (onground == true || wallSlide == true){
                    canDash = true;
                }
                if (onground == true || wallSlide == true){
                    canJump = true;
                } else {
                    canJump = false;
                }
                if (rawInputs.includes("w") == false && rawInputs.includes("s") == false){
                    facingY = "neutral"
                }
                let left = round(getOffset(player).left);
                let right = round(getOffset(player).right);
                if (round(left) == round(wallL[0]) || round(right) == round(wallR[0])){
                    touchingWall = true;
                } else {
                    wallSlide = false;
                    touchingWall = false;
                }
                if (onground == true){
                    wallSlide = false;
                }
                if (wallSlide == true){
                    gravityCap = -gravity*.5;
                } else {
                    gravityCap = -jumpSpd;
                }
            }

             //Global/Player
            async function movementBuffer(event, mode){
                let key = event.key.toLowerCase()
                if (event.repeat == false){
                    if (mode == true){
                        if (rawInputs.includes(key) == false){
                            rawInputs.push(key);
                        }
                    } else {
                        if (rawInputs.includes(key) == true){
                            rawInputs.splice(rawInputs.indexOf(key), 1);
                        }
                    }
                }
            }

             //Global/Player
            async function controlLoop(){
                let inputs = [...rawInputs]
                if (inputs.includes("a") && inputs.includes("d")){
                    if (inputs.indexOf("d") > inputs.indexOf("a")){
                        inputs.splice(inputs.indexOf("d"))
                    } else if (inputs.indexOf("a") > inputs.indexOf("d")){
                        inputs.splice(inputs.indexOf("a"))
                    }
                }
                for (let i in inputs){
                    key = inputs[i];
                    switch (key){
                        default:
                            break;
                        case "alt":
                            rawInputs = [];
                            break;
                        case "tab":
                            rawInputs = [];
                            break;
                        case "t":
                            screenPanning();
                            break;
                        case "l":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            step()
                            break;
                        case "escape":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (menuOpen == false && isPaused == false){
                                isPaused = true;
                            }
                            selectedMenuButton = "";
                            menuManager()
                            break;
                        case "w":
                            if (menuOpen == false){
                                facingY = "up";
                            } else {
                                rawInputs.splice(rawInputs.indexOf(key,1))
                                menuSelect("up")
                            }
                            break;
                        case "s":
                            if (menuOpen == false){
                                facingY = "down";
                            } else {
                                rawInputs.splice(rawInputs.indexOf(key,1))
                                menuSelect("down")
                            }
                            break;
                        case "a":
                            if (isDashing == false){
                                if (wallSlide == false){
                                    facingX = "left";
                                }
                                if (momentum["x"] > -moveSpd){
                                    momentum["x"] -= accelSpd;
                                    if (momentum["x"] < -moveSpd){
                                        momentum["x"] = -moveSpd;
                                    }
                                }
                            }
                            break;
                        case "d":
                            if (isDashing == false){
                                if (wallSlide == false){
                                    facingX = "right";
                                }
                                if (momentum["x"] < moveSpd){
                                    momentum["x"] += accelSpd;
                                    if (momentum["x"] > moveSpd){
                                        momentum["x"] = moveSpd;
                                    }
                                }
                            }
                            break;
                        case " ":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (canJump == true){
                                gravTime = 0;
                                if (wallSlide == true){
                                    if (facingX == "right"){
                                        momentum["x"] = moveSpd*2;
                                    } else {
                                        momentum["x"] = -moveSpd*2;
                                    }
                                }
                                momentum["y"] = jumpSpd;
                            }
                            break;
                        case "shift":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (dashCd == 0 && canDash == true){
                                dash()
                            }
                            break;
                        case "enter":
                            rawInputs.splice(rawInputs.indexOf(key,1))
                            if (menuOpen == true){
                                click()
                            }
                            break;
                    }
                }
            }

             //Individual
            async function dash(){
                isDashing = true;
                canDash = false;
                dashCd = 0.3, gravTime = 0;
                gravityEnabled = false, dragEnabled = false;
                let xHold = momentum["x"];
                momentum["y"] = 0;
                if (facingX == "right"){
                    momentum["x"] = dashSpd;
                } else {
                    momentum["x"] = -dashSpd;
                }
                let now = ingameTime;
                while (ingameTime < now+0.15){await sleep(1)}
                gravityEnabled = true, dragEnabled = true;
                momentum["x"] = xHold;
                isDashing = false;
            }

             //Individual
            function moveMomentum(){
                let x = momentum["x"], y = momentum["y"];
                let left = round(getOffset(player).left), bottom = round(getOffset(player).bottom), right = round(getOffset(player).right), top = round(getOffset(player).top);
                if (x > 0 && y > 0){
                    if (right + x >= cornerX[0] && top + y >= cornerY[0]){
                        if (cornerY[0]-top>cornerX[0]-right){
                            momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x < 0 && y > 0){
                    if (left + x <= cornerX[0] && top + y >= cornerY[0]){
                        if (cornerY[0]-top>left-cornerX[0]){
                            momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x > 0 && y < 0){
                    if (right + x >= cornerX[0] && bottom + y <= cornerY[0]){
                        if (bottom-cornerY[0]>cornerX[0]-right){
                            momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                } else if (x < 0 && y < 0){
                    if (left + x <= cornerX[0] && bottom + y <= cornerY[0]){
                        if (bottom-cornerY[0]>left-cornerX[0]){
                            momentum["x"] = 0;
                        } else {
                            momentum["y"] = 0;
                        }
                    }
                }
                x = momentum["x"], y = momentum["y"];
                if (x > 0){
                    let newDist = left + x;
                    if (newDist >= wallR[0] - getOffset(player).width){
                        if (onground == false){
                            wallSlide = true;
                            facingX = "left";
                        }
                        newDist = wallR[0] - getOffset(player).width - 0.00001;
                        momentum["x"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.left = `${newDist}px`;
                    if (dragEnabled == true){
                        if (onground == true){
                            momentum["x"] = momentum["x"]-groundDrag;
                            if (momentum["x"] < 0){
                                momentum["x"] = 0;
                            }
                        } else {
                            momentum["x"] = momentum["x"]-airDrag;
                            if (momentum["x"] < 0){
                                momentum["x"] = 0;
                            }
                        }
                    }
                } else if (x < 0){
                    let newDist = left + x;
                    if (newDist <= wallL[0]){
                        if (onground == false){
                            wallSlide = true;
                            facingX = "right";
                        }
                        newDist = wallL[0] + 0.00001;
                        momentum["x"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.left = `${newDist}px`;
                    if (dragEnabled == true){
                        if (onground == true){
                            momentum["x"] = momentum["x"]+groundDrag;;
                            if (momentum["x"] > 0){
                                momentum["x"] = 0;
                            }
                        } else {
                            momentum["x"] = momentum["x"]+airDrag;
                            if (momentum["x"] > 0){
                                momentum["x"] = 0;
                            }
                        }
                    }
                }
                if (y > 0){
                    let newDist = bottom + y;
                    if (newDist >= ceiling[0] - getOffset(player).height){
                        newDist = ceiling[0] - getOffset(player).height;
                        momentum["y"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.bottom = `${newDist}px`;
                    
                } else if (y < 0){
                    let newDist = bottom + y;
                    if (newDist <= ground[0]){
                        newDist = ground[0];
                        momentum["y"] = 0;
                    }
                    newDist = round(newDist, 3);
                    document.getElementById(player).style.bottom = `${newDist}px`;
                }
            }
            
             //Individual
            function collisionDetect(){
                platforms = document.querySelectorAll(".platform");
                damaging = document.querySelectorAll(".damaging");
                let topP = round(getOffset(player).top), bottomP = round(getOffset(player).bottom), leftP = round(getOffset(player).left), rightP = round(getOffset(player).right);
                groundCollision = {}, ceilingCollision = {}, wallLCollision = {}, wallRCollision = {};
                //obtain planes from div
                for (let i of platforms){
                    let focus = i.id, bottom = getOffset(focus).bottom, top = getOffset(focus).top, left = getOffset(focus).left, right = getOffset(focus).right;
                    groundCollision[focus] = {"y":top, "x1":left, "x2":right, "id":focus};
                    ceilingCollision[focus] = {"y":bottom, "x1":left, "x2":right, "id":focus};
                    wallLCollision[focus] = {"x":right, "y1":bottom, "y2":top, "id":focus};
                    wallRCollision[focus] = {"x":left, "y1":bottom, "y2":top, "id":focus};
                }
                let damageEntity = []
                for (let i of damaging){
                    damageEntity.push(i.id)
                }

                let valid = [];
                for (let i in wallRCollision){
                    i = wallRCollision[i];
                    let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                    if (rightP <= x && topP > y1 && bottomP < y2){
                        if (damageEntity.includes(id)==true){
                            valid.push([x, "dmg"]);
                        } else {
                            valid.push([x, "none"]);
                        }
                    }
                }
                wallR = valid.sort((a,b) => {return a[0]-b[0]})[0]
                if (wallR == undefined){wallR = [NaN, "none"];}
                
                valid = [];
                for (let i in wallLCollision){
                    i = wallLCollision[i];
                    let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                    if (leftP >= x && topP > y1 && bottomP < y2){
                        if (damageEntity.includes(id)==true){
                            valid.push([x, "dmg"]);
                        } else {
                            valid.push([x, "none"]);
                        }
                    }
                }
                wallL = valid.sort((a,b) => {return b[0]-a[0]})[0]
                if (wallL == undefined){wallL = [NaN, "none"];}
                
                valid = [];
                for (let i in ceilingCollision){
                    i = ceilingCollision[i];
                    let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                    if (topP <= y && rightP > x1 && leftP < x2){
                        if (damageEntity.includes(id)==true){
                            valid.push([y, "dmg"]);
                        } else {
                            valid.push([y, "none"]);
                        }
                    }
                }
                ceiling = valid.sort((a,b) => {return a[0]-b[0]})[0]
                if (ceiling == undefined){ceiling = [NaN, "none"];}
                
                valid = [];
                for (let i in groundCollision){
                    i = groundCollision[i]
                    let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                    if (bottomP >= y && rightP > x1 && leftP < x2){
                        if (damageEntity.includes(id)==true){
                            valid.push([y, "dmg"]);
                        } else {
                            valid.push([y, "none"]);
                        }
                    }
                }
                ground = valid.sort((a,b) => {return b[0]-a[0]})[0]
                if (ground == undefined){ground = [NaN, "none"];}

                let x = momentum["x"], y = momentum["y"]
                if (x!=0 && y!= 0){
                    let newTopP = topP + momentum["y"];
                    let newBottomP = bottomP + momentum["y"];
                    let newLeftP = leftP + momentum["x"];
                    let newRightP = rightP + momentum["x"];
                    let valid = []
                    if (x > 0 && y > 0){
                        for (let i in wallRCollision){
                            i = wallRCollision[i];
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];
                            if (rightP <= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in ceilingCollision){
                            i = ceilingCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (topP <= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x < 0 && y > 0){
                        for (let i in wallLCollision){
                            i = wallLCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (leftP >= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in ceilingCollision){
                            i = ceilingCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (topP <= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x > 0 && y < 0){
                        for (let i in wallRCollision){
                            i = wallRCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (rightP <= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return a[0]-b[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in groundCollision){
                            i = groundCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (bottomP >= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    } else if (x < 0 && y < 0){
                        for (let i in wallLCollision){
                            i = wallLCollision[i]
                            let x = i["x"], y1 = i["y1"], y2 = i["y2"], id = i["id"];                            
                            if (leftP >= x && newTopP > y1 && newBottomP < y2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([x, "dmg"]);
                                } else {
                                    valid.push([x, "none"]);
                                }
                            }
                        }
                        cornerX = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerX == undefined){cornerX = [NaN, "none"];}
                        valid = [];
                        for (let i in groundCollision){
                            i = groundCollision[i]
                            let y = i["y"], x1 = i["x1"], x2 = i["x2"], id = i["id"];
                            if (bottomP >= y && newRightP > x1 && newLeftP < x2){
                                if (damageEntity.includes(id)==true){
                                    valid.push([y, "dmg"]);
                                } else {
                                    valid.push([y, "none"]);
                                }
                            }
                        }
                        cornerY = valid.sort((a,b) => {return b[0]-a[0]})[0]
                        if (cornerY == undefined){cornerY = [NaN, "none"];}
                    }
                }
            }

             //Global/Player
            function screenPanning(){
                let screenCenterX = round(winWidth/2), screenCenterY = round(winHeight*0.4);
                let playerCenterX = round(round(getOffset(player).left) + getOffset(player).width/2,1), playerCenterY = round(getOffset(player).bottom);
                let elements = document.getElementById("gameArea").querySelectorAll("div");
                let origin = {"x":getOffset("origin").left, "y":getOffset("origin").bottom};
                if (screenCenterX != playerCenterX){
                    let panDistX = Math.sign(screenCenterX-playerCenterX)*round(panSpeedX*Math.log2(Math.abs(screenCenterX-playerCenterX)/screenCenterX+1),3);
                    if (origin["x"]+panDistX > 0){
                        panDistX = 0-origin["x"]
                    }
                    for (let i=0; i<elements.length; i++){
                        let target = elements[i].id;
                        let newPos = round(getOffset(target).left+panDistX);
                        if (Math.abs(panDistX)<0.5 && Math.abs(panDistX)>0.05){
                            newPos = getOffset(target).left+Math.sign(screenCenterX-playerCenterX);
                        }
                        document.getElementById(target).style.left = `${newPos}px`;
                    }
                }
                
                if (screenCenterY != playerCenterY){
                    let panDistY = Math.sign(screenCenterY-playerCenterY)*round(panSpeedY*Math.log2(Math.abs(screenCenterY-playerCenterY)/screenCenterY+1),3);
                    if (origin["y"]+panDistY > 0){
                        panDistY = 0-origin["y"];
                    }
                    for (let i=0; i<elements.length; i++){
                        let target = elements[i].id;
                        let newPos = round(getOffset(target).bottom+panDistY);
                        if (Math.abs(panDistY)<0.5 && Math.abs(panDistY)>0.05){
                            newPos = getOffset(target).bottom+Math.sign(screenCenterY-playerCenterY);
                        }
                        document.getElementById(target).style.bottom = `${newPos}px`;
                    }
                }
            }

             //Individual
            function checkDamage(){
                let top = round(getOffset(player).top), bottom = round(getOffset(player).bottom), left = round(getOffset(player).left), right = round(getOffset(player).right);
                if (top == ceiling[0] && ceiling[1] == "dmg"){
                    damage(player, Infinity)
                }
                if (bottom == ground[0] && ground[1] == "dmg"){
                    damage(player, Infinity)
                }
                if (left == wallL[0] && wallL[1] == "dmg"){
                    damage(player, Infinity)
                }
                if (right == wallR[0] && wallR[1] == "dmg"){
                    damage(player, Infinity)
                }
            }

             //Global
            async function damage(target, amount){
                isPaused = true;
                await sleep(200)
                if (target == player){
                    playerHealth -= amount;
                    if (playerHealth <= 0){
                        killPlayer()
                    }
                }
                isPaused = false;
            }

             //Global
            function killPlayer(){
                let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                document.getElementById(player).style.left = `${originX+spawnPoint["x"]}px`
                document.getElementById(player).style.bottom = `${originY+spawnPoint["y"]}px`
                playerSetup()
                for (let i=0; i<1000; i++){
                    screenPanning()
                }
            }

             //Global
            async function createPlatform(points, modifier){
                //[200, 100], [200, 200], [150, 200], [150, 150], [100, 150], [100, 100]
                let originX = getOffset("origin").left, originY = getOffset("origin").bottom;
                /*
                for (let i=0; i<points.length; i+=2){
                    let j = i+1
                    if (j > points.length-1){
                        return
                    }
                    pl1=points[i]
                    pl2=points[j]
                    let platNum = 0
                    for (let k=0; k<platforms.length; k++){
                        if (platforms[k].id.substr(0,4) == "plat"){
                            platNum = Number(platforms[k].id.substr(4))+1;
                        }
                    }
                    document.getElementById("gameArea").innerHTML += `<div id="plat${platNum}" class="platform"></div>`;
                    if (pl1[0] <= pl2[0]){
                        document.getElementById(`plat${platNum}`).style.left = `${originX+pl1[0]}px`;
                    } else if (pl1[0] > pl2[0]) {
                        document.getElementById(`plat${platNum}`).style.left = `${originX+pl2[0]}px`;
                    }
                    if (pl1[1] <= pl2[1]){
                        document.getElementById(`plat${platNum}`).style.bottom = `${originY+pl1[1]}px`;
                    } else if (pl1[1] > pl2[1]) {
                        document.getElementById(`plat${platNum}`).style.bottom = `${originY+pl2[1]}px`;
                    }
                    if (pl1[0] - pl2[0] != 0){
                        document.getElementById(`plat${platNum}`).style.width = `${Math.abs(pl1[0]-pl2[0])}px`;
                    } else {
                        document.getElementById(`plat${platNum}`).style.width = `1px`;
                    }
                    if (pl1[1] - pl2[1] != 0){
                        document.getElementById(`plat${platNum}`).style.height = `${Math.abs(pl1[1]-pl2[1])}px`;
                    } else {
                        document.getElementById(`plat${platNum}`).style.height = `1px`;
                    }
                    await sleep(25)
                }*/
                
                if (points.length==2){
                    let exists = []
                    let platNum = 0
                    platforms = document.querySelectorAll(".platform");
                    for (let i=0; i<platforms.length; i++){
                        if (platforms[i].id.substr(0,4) == "plat"){
                            exists.push(Number(platforms[i].id.substr(4)))
                        }
                    }
                    for (let i=1; i<=platforms.length; i++){
                        let j = i
                        while (exists.includes(j)){j++}
                        platNum = j
                    }
                    document.getElementById("gameArea").innerHTML += `<div id="plat${platNum}" class="platform ${modifier}"></div>`;
                    let selected = document.getElementById(`plat${platNum}`);
                    let width = Math.abs(points[0][0] - points[1][0]);
                    let height = Math.abs(points[0][1] - points[1][1]);
                    let x1 = NaN, y1 = NaN;
                    for (let i of points){
                        if (isNaN(x1)==true){
                            x1 = i[0];
                        } else if (i[0] < x1){
                            x1 = i[0];
                        }
                        if (isNaN(y1)==true){
                            y1 = i[1];
                        } else if (i[1] < y1){
                            y1 = i[1];
                        }
                    }
                    selected.style.left = `${originX+x1}px`;
                    selected.style.bottom = `${originY+y1}px`;
                    selected.style.width = `${width}px`;
                    selected.style.height = `${height}px`;
                } else if (points.length == 4){

                } else {
                    console.log("Not implemented yet")
                }
            }

            //Debug
            async function step(n=1){
                isPaused = false;
                await sleep(25*n)//gameSpd
                isPaused = true;
            }

            async function debug(){
                while (true){
                    await sleep(1)
                    updateDisplay()
                }
            }

            function updateDisplay(){
                document.getElementById("realTime").innerHTML = "realTime: " + (new Date() - startTime)/1000;
                document.getElementById("globalTime").innerHTML = "globalTime: " + globalTime;
                document.getElementById("ingameTime").innerHTML = "ingameTime: " + ingameTime;
                document.getElementById("isPaused").innerHTML = "isPaused: " + isPaused;
                document.getElementById("gameSpd").innerHTML = "gameSpd: " + gameSpd;
                document.getElementById("momentum").innerHTML = `x: ${momentum["x"]} y: ${momentum["y"]}`;
                document.getElementById("gravTime").innerHTML = "GravTime: " + round(gravTime, 3);
                document.getElementById("onGround").innerHTML = "onGround: " + onground;
                document.getElementById("wallSlide").innerHTML = "wallSlide: " + wallSlide;
                document.getElementById("facingX").innerHTML = "facingX: " + facingX;
                document.getElementById("facingY").innerHTML = "facingY: " + facingY;
                document.getElementById("left").innerHTML = "Left: " + getOffset(player).left+ ", "+ wallL;
                document.getElementById("right").innerHTML = "Right: " + getOffset(player).right+ ", "+ wallR;
                document.getElementById("top").innerHTML = "Top: " + getOffset(player).top+ ", "+ ceiling;
                document.getElementById("bottom").innerHTML = "Bottom: " + getOffset(player).bottom+ ", "+ ground;
                document.getElementById("rawInputs").innerHTML = "Inputs: " + [rawInputs];
            }

            function test(){
                let li = [];
                for (let i=10; i>0; i-=2){
                    let a = []
                    a.push(i, i-1)
                    li.push(a)
                }
                console.log(li.sort((a,b)=> {console.log(a[0],b[0]);return a[0]-b[0]}))
            }

            //Menus
            function focusControls(){
                //console.log(new Error().stack)
                document.getElementById("controls").focus();
            }

            async function menuManager(id=""){
                if (menuOpen == false){
                    menuOpen = true;
                    switchMenus("pauseMenu")
                    menuSelect()
                } else {
                    let current = ""
                    for (let i of document.getElementsByClassName("menuGroup")){
                        if (i.hidden == false){
                            current = i.id;
                            break;
                        }
                    }
                    if (id == ""){
                        if (current == "pauseMenu"){
                            isPaused = false;
                            menuOpen = false;
                            document.getElementById("pauseMenu").hidden = true;
                        } else {
                            switch (current){
                                default:
                                    break;
                                case "optionsMenu":
                                    switchMenus("pauseMenu")
                                    break;
                            }
                        }
                    } else {
                        switch (id){
                            default:
                                break;
                            case "optionsBack":
                                switchMenus("pauseMenu")
                                break;
                            case "options":
                                switchMenus("optionsMenu")
                                break;
                        }
                    }
                    menuSelect()
                }
            }

            function switchMenus(menu){
                selectedMenuButton = "";
                for (let i of document.getElementsByClassName("menuGroup")){
                    toggleMenu(i.id, true);
                }
                toggleMenu(menu, false);
            }

            function menuSelect(direction){
                let buttons = [];
                for (let i of document.getElementsByClassName("menu")){
                    if (i.tagName == "BUTTON"){
                        let cl = [...document.getElementById(i.id).classList];
                        if (cl.includes("selected")){
                            cl.splice(cl.indexOf("selected"), 1)
                            document.getElementById(i.id).classList = cl.toString().replace(",", " ");
                        }
                        if (document.getElementById(i.id).parentElement.hidden == false){
                            buttons.push(i.id)
                        }
                    }
                }
                if (buttons.length > 0){
                    if (selectedMenuButton == ""){
                        selectedMenuButton = buttons[0];
                    } else {
                        if (direction == "up"){
                            let index = buttons.indexOf(selectedMenuButton)-1
                            if (index < 0){
                                index = buttons.length-1;
                            }
                            selectedMenuButton = buttons[index]
                        } else {
                            let index = buttons.indexOf(selectedMenuButton)+1
                            if (index > buttons.length-1){
                                index = 0;
                            }
                            selectedMenuButton = buttons[index]
                        }
                    }
                    document.getElementById(selectedMenuButton).classList = [document.getElementById(selectedMenuButton).classList + " selected"]
                }
            }

            function click(){
                if (selectedMenuButton != ""){
                    document.getElementById(selectedMenuButton).onclick();
                    for (let i of document.getElementsByClassName("menu")){
                        if (i.tagName == "BUTTON" && i.id != selectedMenuButton){
                            let cl = [...document.getElementById(i.id).classList];
                            if (cl.includes("selected")){
                                cl.splice(cl.indexOf("selected"), 1)
                                document.getElementById(i.id).classList = cl.toString().replace(",", " ");
                            }
                        }
                    }
                }
            }

            function toggleMenu(id, pref=""){
                if (id == ""){return}
                if (pref == ""){
                    if (document.getElementById(id).hidden == true){
                        document.getElementById(id).hidden = false;
                    } else {
                        document.getElementById(id).hidden = true;
                    }
                } else {
                    document.getElementById(id).hidden = pref;
                }
            }

            function scrollMenu(menu){
                
            }

        </script>
    </head>
    <body onload="pageLoad()" onblur="if(isPaused==false){rawInputs.push('escape')}">
        <div id="debug">
            <label id="realTime"></label><br>
            <label id="globalTime"></label><br>
            <label id="ingameTime"></label><br>
            <label id="isPaused"></label><br>
            <label id="gameSpd"></label><br>
            <label id="momentum"></label><br>
            <label id="gravTime"></label><br>
            <label id="onGround"></label><br>
            <label id="wallSlide"></label><br>
            <label id="facingX"></label><br>
            <label id="facingY"></label><br>
            <label id="left"></label><br>
            <label id="right"></label><br>
            <label id="top"></label><br>
            <label id="bottom"></label><br>
            <label id="rawInputs"></label><br>
        </div>
        <div id="gameArea">
            <input id="controls" autofocus onkeydown="movementBuffer(event, true)" onkeyup="movementBuffer(event, false)" onblur="focusControls()">
            <div id="origin"></div>
            <div id="player"></div>
            <div id="plat1" class="platform"></div>
            <div id="plat2" class="platform"></div>
            <div id="plat3" class="platform"></div>
            <div id="plat4" class="platform"></div>
            <div id="plat5" class="platform"></div>
            <div id="plat6" class="platform"></div>
            <div id="plat7" class="platform"></div>
            <div id="plat8" class="platform"></div>
            <div id="plat9" class="platform damaging"></div>
            <div id="floor" class="platform"></div>
            <div id="wall" class="platform"></div>
            <div id="deathPlane" class="platform damaging"></div>
        </div>
        <div id="pauseMenu" class="menuGroup" hidden>
            <h1 class="menu center">Paused</h1>
            <button id="resume" class="menu center" onclick="menuManager()">Resume</button><br><br>
            <button id="options" class="menu center" onclick="menuManager(id)">Options</button><br><br>
            <button id="quit" class="menu center" onclick="alert('No quitting!')">Save & Quit</button>
        </div>
        <div id="optionsMenu" class="menuGroup" hidden parent="pauseMenu">
            <h1 class="menu center">Options</h1>
            <button id="debugToggle" class="menu center" onclick="toggleMenu('debug')">Toggle Debug</button><br><br>
            <button id="temp2" class="menu center" onclick="focusControls()">Temp</button><br><br>
            <button id="optionsBack" class="menu center" onclick="menuManager(id)">Back</button>
        </div>
    </body>
</html>