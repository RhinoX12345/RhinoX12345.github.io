<!DOCTYPE html>
<html>
    <head>
        <title>Sudoku</title>
        <style>
            body{
                width:max-content;
                font-family:"Segoe UI";
            }

            table{
                color:black;
                border:1px solid black;
                border-spacing:0;
                text-align:center;
                background-color:rgb(240, 248, 255);
                font-size:25px;
            }

            td{
                height:50px;
                width:50px;
                padding:0;
                border:1px solid black;
                cursor:pointer;
            }

            #spacer {
                height:0px;
                width:0px;
            }

            .notes {
                position: relative;
                top: 0px;
                display:grid;
                width:auto;
                height:auto;
                grid-template-columns: 33.3% 33.3% 33.3%;
                grid-template-rows: 33.3% 33.3% 33.3%;
                grid-template-areas: "n1 n2 n3" "n4 n5 n6" "n7 n8 n9";
                font-size: 12px;
                color: gray;
            }

            #n1 {grid-area: "n1";}
            #n2 {grid-area: "n2";}
            #n3 {grid-area: "n3";}
            #n4 {grid-area: "n4";}
            #n5 {grid-area: "n5";}
            #n6 {grid-area: "n6";}
            #n7 {grid-area: "n7";}
            #n8 {grid-area: "n8";}
            #n9 {grid-area: "n9";}

            #number{
                position:absolute;
                top: 60px;
                left: 500px;
            }
            #number tr :hover{
                background-color:rgb(220, 228, 235);
            }

            button {
                margin: 3px 0px;
                border: 1px solid black;
                border-radius: 2px;
            }

            input{
                width:600px;
                margin: 3px 0px;
            }

            .otherMenus {
                position: absolute;
                right: 5px;
                top: 5px;
            }
            
        </style>
        <script>
            const cells = [
                '11', '21', '31', '41', '51', '61', '71', '81', '91', 
                '12', '22', '32', '42', '52', '62', '72', '82', '92', 
                '13', '23', '33', '43', '53', '63', '73', '83', '93', 
                '14', '24', '34', '44', '54', '64', '74', '84', '94', 
                '15', '25', '35', '45', '55', '65', '75', '85', '95', 
                '16', '26', '36', '46', '56', '66', '76', '86', '96', 
                '17', '27', '37', '47', '57', '67', '77', '87', '97', 
                '18', '28', '38', '48', '58', '68', '78', '88', '98', 
                '19', '29', '39', '49', '59', '69', '79', '89', '99'];
            const groups = {
                1: ['11', '21', '31', '12', '22', '32', '13', '23', '33'], 
                2: ['41', '51', '61', '42', '52', '62', '43', '53', '63'], 
                3: ['71', '81', '91', '72', '82', '92', '73', '83', '93'], 
                4: ['14', '24', '34', '15', '25', '35', '16', '26', '36'], 
                5: ['44', '54', '64', '45', '55', '65', '46', '56', '66'], 
                6: ['74', '84', '94', '75', '85', '95', '76', '86', '96'], 
                7: ['17', '27', '37', '18', '28', '38', '19', '29', '39'], 
                8: ['47', '57', '67', '48', '58', '68', '49', '59', '69'], 
                9: ['77', '87', '97', '78', '88', '98', '79', '89', '99']};
            const sleep = (sleep) => new Promise((resolve) => setTimeout(resolve, sleep))
            selectedCell="", board=[], boardCells={}, noting=false;
            code = "000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            answer = "";
            debugStep = false, debugStepped = false;

            async function pageLoad(){
                //debugStep=true;
                //debugStepped=true;
                setup();
                await sleep(20)
                //loadRandom()
                test();
                await sleep(20)
                //bot();
            }

            function setup(){
                document.getElementById("output").value="";
                document.getElementById("board").innerHTML="";
                for (let i=1; i<=9; i++){
                    document.getElementById("board").innerHTML+=`<tr id=${i}></tr>`;
                    if (i%3==0 && i!=9){
                        document.getElementById("board").innerHTML+='<tr id="spacer"><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td><td id="spacer"></td></tr>';
                    }
                    for (let j=1; j<=9; j++){
                        document.getElementById(i).innerHTML+=`<td id=${j}${i} content notes></td>`;
                        if (j%3==0 && j!=9){
                            document.getElementById(i).innerHTML+='<td id="spacer"></td>';
                        }
                    }
                }
                if (document.getElementById("code").value!=""){
                    code = document.getElementById("code").value;
                }
                board = code.split("");
                for (let i in board){
                    board[i]=Number(board[i])
                }
                for (let i=0; i<cells.length; i++){
                    if (board[i]!=0){
                        boardCells[cells[i]] = true;
                    } else {
                        boardCells[cells[i]] = false;
                    }
                }

                for (let i=0; i<cells.length; i++){
                    if (boardCells[cells[i]]==true){
                        document.getElementById(cells[i]).innerHTML = board[i];
                        document.getElementById(cells[i]).attributes["content"]["value"] = board[i];
                    }
                    document.getElementById(cells[i]).addEventListener("click", e=>click(cells[i]));
                }
                snapShot = {}
                let ans = checkUnique(code)[1];
                document.getElementById("answer").value = ans;
                answer = ans
                return "Done"
            }

            function click(id){
                let lightblue = "rgb(240, 248, 255)";
                let lightgray = "rgb(215, 223, 230)";
                let darkgray = "rgb(185, 190, 195)";
                selectedCell = id;
                for (let i in cells){
                    document.getElementById(cells[i]).style.backgroundColor=lightblue;
                }
                for (let i=1; i<=9; i++){
                    document.getElementById(`${i}${id[1]}`).style.backgroundColor=lightgray;
                    document.getElementById(`${id[0]}${i}`).style.backgroundColor=lightgray;
                }
                for (let i=1; i<=9; i++){
                    for (let j=1; j<=9; j++){
                        if(Math.ceil(Number(id[0]/3))==Math.ceil(i/3) && Math.ceil(Number(id[1]/3))==Math.ceil(j/3)){
                            document.getElementById(`${i}${j}`).style.backgroundColor=lightgray;
                        }
                        if (document.getElementById(id).attributes["content"]["value"] != "" && document.getElementById(id).attributes["content"]["value"] == document.getElementById(`${i}${j}`).attributes["content"]["value"]){
                            document.getElementById(`${i}${j}`).style.backgroundColor=darkgray;
                        }
                    }
                }
                document.getElementById(id).style.backgroundColor=darkgray;
            }

            function keyInput(event){
                if (event.repeat==false){
                    switch (event.key){
                        case "ArrowUp":
                        if (selectedCell!=""){
                            let y = Number(selectedCell[1])-1;
                            if (y>=1){
                                click(`${selectedCell[0] + String(y)}`)
                            }
                            
                        }
                        break;
                        case "ArrowDown":
                        if (selectedCell!=""){
                            let y = Number(selectedCell[1])+1;
                            if (y<=9){
                                click(`${selectedCell[0] + String(y)}`)
                            }
                        }
                        break;
                        case "ArrowLeft":
                        if (selectedCell!=""){
                            let x = Number(selectedCell[0])-1;
                            if (x>=1){
                                click(`${String(x) + selectedCell[1]}`)
                            }
                        }
                        break;
                        case "ArrowRight":
                        if (selectedCell!=""){
                            let x = Number(selectedCell[0])+1;
                            if (x<=9){
                                click(`${String(x) + selectedCell[1]}`)
                            }
                        }
                        break;
                        case "1":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "2":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "3":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "4":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "5":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "6":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "7":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "8":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "9":
                        if (selectedCell!=""){
                            set(Number(event.key))
                        }
                        break;
                        case "n":
                        toggleNote("note")
                        break;
                        case "Backspace":
                        set(0)
                        break;
                        case "Delete":
                        set(0)
                        break;
                    }
                }
            }

            function set(num){
                if (selectedCell == "" ){
                    return -1;
                }else if (num == 0 && boardCells[selectedCell]==false){
                    document.getElementById(selectedCell).innerHTML="";
                    document.getElementById(selectedCell).attributes["content"]["value"] = "";
                    if (noting){
                        document.getElementById(selectedCell).attributes["notes"]["value"] = "";
                    } else {
                        setNotes(selectedCell, document.getElementById(selectedCell).attributes["notes"]["value"]);
                    }
                } else if (boardCells[selectedCell]==false){
                    if (document.getElementById(selectedCell).attributes["content"]["value"]==""){
                        if (noting==false){
                            document.getElementById(selectedCell).innerHTML = num;
                            document.getElementById(selectedCell).attributes["content"]["value"] = num;
                            document.getElementById(selectedCell).style.color = "blue";
                            document.getElementById(selectedCell).style.fontSize="25px";
                            if(true){
                                compare()
                            }
                        } else {
                            let notes = document.getElementById(selectedCell).attributes["notes"]["value"];
                            notes = notes.trim(",").split(",").sort()
                            let temp = []
                            for (let i of notes){
                                if (i == ''){continue}
                                temp.push(Number(i))
                            }
                            notes = temp;
                            if (notes.includes('')){notes.splice(notes.indexOf(''), 1)}
                            if (notes.includes(num)==false){
                                notes.push(num);
                                notes = notes.sort();
                            } else {
                                notes.splice(notes.indexOf(num), 1);
                            }
                            document.getElementById(selectedCell).attributes["notes"]["value"] = notes;
                            setNotes(selectedCell, notes)
                        }
                    }
                }
                click(selectedCell);
                for (let i in cells){
                    if (document.getElementById(cells[i]).innerHTML==""){
                        return -1;
                    }
                }
                return "Finished"
            }

            function toggleNote(id){
                if (noting==true){
                    noting=false;
                    document.getElementById(id).style.backgroundColor="rgb(240, 248, 255)";
                } else {
                    noting=true;
                    document.getElementById(id).style.backgroundColor="rgb(190, 210, 230)";
                }
            }

            function hoverNote(id, state){
                if (state){
                    document.getElementById(id).style.backgroundColor='rgb(220, 228, 235)';
                } else {
                    if (noting){
                        document.getElementById(id).style.backgroundColor="rgb(190, 210, 230)";
                    } else {
                        document.getElementById(id).style.backgroundColor="rgb(240, 248, 255)";
                    }
                }
            }

            function setNotes(id, notes){
                document.getElementById(id).innerHTML = '<div class="notes"></div>';
                for (let i of document.getElementsByClassName("notes")){
                    if (i.parentElement.id==id){
                        for (let j=1; j<=9; j++){
                            if (notes.includes(j)){
                                i.innerHTML += `<div id="n${j}">${j}</div>`;
                            } else {
                                i.innerHTML += `<div id="n${j}"><br></div>`;
                            }
                        }
                    }
                }
            }

            async function bot(){
                const link = (primary, secondary, n)=>{//return array[row/col, group]; key: true (strong link), false (weak link), undefined (no link)
                    if (primary == secondary){return undefined;}
                    if (Object.values(numberProfile[n]).includes(primary)==false || Object.values(numberProfile[n]).includes(secondary)==false){
                        return undefined;
                    }
                    let returnVal = [];
                    if (primary[0] == secondary[0]){
                        let strong = true;
                        for (let t=1; t<=9; t++){
                            let check = `${primary[0]}${t}`;
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    } else if (primary[1] == secondary[1]){
                        let strong = true;
                        for (let t=1; t<=9; t++){
                            let check = `${t}${primary[1]}`;
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    }
                    let gPrim = Math.ceil(Number(primary[1])/3)*3-3+Math.ceil(Number(primary[0])/3);
                    let gSec = Math.ceil(Number(secondary[1])/3)*3-3+Math.ceil(Number(secondary[0])/3);
                    if (gPrim == gSec){
                        let strong = true;
                        for (let t of groups[gPrim]){
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    }
                    return returnVal
                }
                let delay = 10;
                cellProfile = {}, numberProfile = {1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[]}, boardLayout = {}, snapShot = {};
                for (let i in cells){
                    boardLayout[cells[i]] = board[i];
                    if (board[i]==0){
                        let temp = document.getElementById(cells[i]).innerHTML;
                        if (temp.length==1){
                            boardLayout[cells[i]] = Number(temp);
                        }
                    }
                }
                for (let i of Object.keys(boardLayout)){
                    if (boardLayout[i]==0){
                        cellProfile[i]=[1,2,3,4,5,6,7,8,9];
                        document.getElementById(i).innerHTML = "";
                    }
                }
                for (let i in cellProfile){
                    for (let j in cellProfile[i]){
                        numberProfile[cellProfile[i][j]] = [numberProfile[cellProfile[i][j]],i].flat().filter((value) => {return value!=undefined});
                    }
                }
                console.log("Bot Start")
                let change = 0;
                let step = 0;
                let log = [];
                while(true && step<100){
                    if (fill){
                        if (change > 0){
                            let cellOutput = {}
                            for (let i in cellProfile){//sets tiles for only possible number
                                if (cellProfile[i].length == 1){
                                    boardLayout[i] = cellProfile[i][0];
                                    cellOutput[i] = cellProfile[i][0];
                                    numberProfile[cellProfile[i][0]].splice(numberProfile[cellProfile[i][0]].indexOf(i), 1)
                                    click(i);
                                    set(cellProfile[i][0]);
                                    cellProfile[i]=[];
                                    if (delay>0){
                                        await sleep(delay);
                                    }
                                }
                            }
                            if (Object.keys(cellOutput).length > 0){
                                log.push(cellOutput)
                                console.log("Cell Output:", cellOutput);
                            }
                        }
                    }
                    if (step > 0){
                        let tempSnapshot = {}
                        let key = "";
                        for (let i of cells){
                            if (Object.keys(cellProfile).includes(i)){
                                tempSnapshot[i] = cellProfile[i];
                                key+="0";
                            } else {
                                tempSnapshot[i] = Number(document.getElementById(i).attributes["content"]["value"]);
                                key+=Number(document.getElementById(i).attributes["content"]["value"]);
                            }
                        }
                        tempSnapshot["key"] = key;
                        snapShot[step] = tempSnapshot
                        //console.log("Snapshot", snapShot)
                    }
                    if (change > 0){change=0;}
                    step++;
                    console.log("Step:", step)
                    lastStep = step - 1
                    for (let i=0; i<1; i++){//removes empty cells from cellProfile
                        let tempObj = {...cellProfile};
                        for (let j in cellProfile){
                            if (cellProfile[j]==[]){
                                delete tempObj[j]
                            }
                        }
                        cellProfile = {...tempObj}
                    }
                    if (debugStep==true){
                        let groupProfile = new Map();
                        for (let i=1; i<=9; i++){
                            for (let j=0;j<groups[i].length;j++){
                                if (Object.keys(cellProfile).includes(groups[i][j])==true && cellProfile[groups[i][j]].length!=0){
                                    groupProfile.set(groups[i][j],cellProfile[groups[i][j]]);
                                }
                            }
                        }
                        for (let i in cells){
                            if(boardLayout[cells[i]]==0){
                                for (let j of groupProfile.entries()){
                                    document.getElementById(j[0]).innerHTML = j[1];
                                    document.getElementById(j[0]).style.fontSize="10px";
                                }
                            }
                        }
                        while(debugStepped==false){
                            await sleep(50);
                        }
                        for (let i in cellProfile){
                            if (String(document.getElementById(i).innerHTML).length!=1){
                                document.getElementById(i).innerHTML = "";  
                                document.getElementById(i).style.fontSize="25px";
                            }
                        }
                        debugStepped=false;
                    }
                    for (let i of Object.keys(cellProfile)){//Obvious single
                        let localChange = 0;
                        let values = cellProfile[i];
                        let group = Math.ceil(Number(i[1])/3)*3-3+Math.ceil(Number(i[0])/3);
                        for (let j=1; j<=9; j++){//row
                            let tempValue = boardLayout[`${i[0]}${j}`];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        for (let j=1; j<=9; j++){//col
                            let tempValue = boardLayout[`${j}${i[1]}`];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        for (let j of groups[group].filter((val)=>{return val!=i})){//group
                            let tempValue = boardLayout[j];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        if (localChange>0){console.log("Obvious Single");}
                    }
                    if (change > 0){log.push(["ObvSingle", change]);continue;}
                    
                    //Obvious Pairs
                    if (obviousPair){
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a group
                            let numList = [...groups[i]];
                            for (let j in numList){
                                let cell = numList[j];
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k in numList){
                                        let neighbor = numList[k];
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m in numList){
                                                        let target = numList[m];
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            console.log("Obvious Pair Group");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a col
                            for (let j=1; j<=9; j++){
                                let cell = `${i}${j}`;
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k=1; k<=9; k++){
                                        let neighbor = `${i}${k}`;
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m=1; m<=9; m++){
                                                        let target = `${i}${m}`;
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            console.log("Obvious Pair Col");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a row
                            for (let j=1; j<=9; j++){
                                let cell = `${j}${i}`;
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k=1; k<=9; k++){
                                        let neighbor = `${k}${i}`;
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m=1; m<=9; m++){
                                                        let target = `${m}${i}`;
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            console.log("Obvious Pair Row");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvPair", change]);continue;}
                    }
                    
                    //Obvious Triple
                    if (obviousTriple){
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => groups[i].includes(key) && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => groups[i].includes(key))){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                console.log("Obvious Triple Group");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0] == i && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => key[0] == i)){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                console.log("Obvious Triple Col");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1] == i && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => key[1] == i)){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                console.log("Obvious Triple Row");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvTriple", change]);continue;}
                    }
                    
                    //Obvious Quad
                    if (obviousQuad){
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => groups[i].includes(key) && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => groups[i].includes(key))){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    console.log("Obvious Quad Group");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0] == i && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => key[0] == i)){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    console.log("Obvious Quad Col");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1] == i && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => key[1] == i)){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    console.log("Obvious Quad Row");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvQuad", change]);continue;}
                    }
                    
                    //Hidden Single
                    if (hiddenSingle){
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in group
                            let group = [...groups[i]];
                            let unfilled = group.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of group.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        console.log("Hidden Single Group", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in col
                            let col = [];
                            for (let j=1; j<=9; j++){
                                col.push(`${i}${j}`);
                            }
                            let unfilled = col.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of col.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        console.log("Hidden Single Col", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in row
                            let row = [];
                            for (let j=1; j<=9; j++){
                                row.push(`${j}${i}`);
                            }
                            let unfilled = row.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of row.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        console.log("Hidden Single Row", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenSingle", change]);continue;}
                    }

                    //Hidden Pairs
                    if (hiddenPair){
                        for (let i=1; i<=9; i++){//group
                            let possibleNum = [];
                            for (let j in groups[i]){
                                if (Object.keys(cellProfile).includes(groups[i][j])==true){
                                    possibleNum.push(cellProfile[groups[i][j]]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l in groups[i]){
                                                for (let m in groups[i]){
                                                    let cell1 = groups[i][l], cell2 = groups[i][m];
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                console.log("Hidden Pair Group")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let possibleNum = [];
                            for (let j=1; j<=9; j++){
                                let cell = `${i}${j}`;
                                if (Object.keys(cellProfile).includes(cell)==true){
                                    possibleNum.push(cellProfile[cell]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l=1; l<=9; l++){
                                                for (let m=1; m<=9; m++){
                                                    let cell1 = `${i}${l}`, cell2 = `${i}${m}`;
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                console.log("Hidden Pair Row")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let possibleNum = [];
                            for (let j=1; j<=9; j++){
                                let cell = `${j}${i}`;
                                if (Object.keys(cellProfile).includes(cell)==true){
                                    possibleNum.push(cellProfile[cell]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l=1; l<=9; l++){
                                                for (let m=1; m<=9; m++){
                                                    let cell1 = `${l}${i}`, cell2 = `${m}${i}`;
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                console.log("Hidden Pair Col")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenPair", change]);continue;}
                    }
                    
                    //Hidden Triple
                    if (hiddenTriple){
                        for (let i=1; i<=9; i++){//group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => Object.values(groups[i]).includes(key));
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                console.log("Hidden Triple Group");
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                console.log("Hidden Triple Col");
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                console.log("Hidden Triple Row", cell, m, [temp[j],temp[k],temp[l]]);
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenTriple", change]);continue;}
                    }
                    
                    //Hidden Quads
                    if (hiddenQuad){
                        for (let i=1; i<=9; i++){//group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => Object.values(groups[i]).includes(key));
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    console.log("Hidden Quad Group");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    console.log("Hidden Quad Col");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    console.log("Hidden Quad Col");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenQuad", change]);continue;}
                    }
                    
                    //Pointing Pairs & Pointing Triple
                    if (pointingPairTriple){
                        for (let i in groups){
                            let possibleNum = [];
                            let temp = groups[i].filter((val)=>{return Object.keys(cellProfile).includes(val)})
                            for (let j of temp){
                                possibleNum.push(Object.values(cellProfile[j]))
                            }
                            possibleNum = possibleNum.flat().sort();
                            let temp2 = [];
                            for (let j of possibleNum){
                                if (temp2.includes(j)==false){
                                    temp2.push(j)
                                }
                            }
                            for (let j of temp2){
                                let amount = 0;
                                if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                    amount = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                }
                                if (amount == 2){
                                    let neighbors = temp.filter((val)=>{return Object.values(cellProfile[val]).includes(j)})
                                    if (neighbors[0][0] == neighbors[1][0]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${neighbors[0][0]}${k}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                console.log("Pointing Pair Row");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    } else if (neighbors[0][1] == neighbors[1][1]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${k}${neighbors[0][1]}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                console.log("Pointing Pair Col");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    }
                                } else if (amount == 3){
                                    let neighbors = temp.filter((val)=>{return Object.values(cellProfile[val]).includes(j)})
                                    if (neighbors[0][0] == neighbors[1][0] && neighbors[1][0] == neighbors[2][0]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${neighbors[0][0]}${k}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                console.log("Pointing Triple Row");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    } else if (neighbors[0][1] == neighbors[1][1] && neighbors[1][1] == neighbors[2][1]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${k}${neighbors[0][1]}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                console.log("Pointing Triple Col");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["PointingPairTriple", change]);continue;}
                    }
                    
                    //Box Line Reduction
                    if (boxLineReduc){
                        //iter through rows per group
                        //for each number, save group & row
                        //for each row, if num of groups == 1: remove other rows in that group
                        for (let i=1; i<9; i+=3){
                            let g1 = i, g2 = i+1, g3 = i+2;
                            for (let j=1; j<=9; j++){
                                let c = [[0,0,0],[0,0,0],[0,0,0]];
                                for (let k of numberProfile[j]){
                                    if (groups[g1].includes(k) || groups[g2].includes(k) || groups[g3].includes(k)){
                                        let group = Math.ceil(Number(k[0])/3)-1;
                                        let row = Number(k[1]%3)!=0 ? Number(k[1]%3)-1 : 2;
                                        c[row][group]+=1
                                    }
                                }
                                for (let row in c){
                                    let total = c[row].reduce((total, value)=>{return total+value})
                                    let max = c[row].reduce((total, value)=>{return total>value ? total : value})
                                    if (total == max && max > 0){
                                        for (let k of numberProfile[j]){
                                            let group = Math.ceil(Number(k[1])/3)*3-3+Math.ceil(Number(k[0])/3);
                                            let tRow = Number(k[1]);
                                            if ([g1,g2,g3][c[row].indexOf(total)]==group){
                                                if (tRow == Number(row)+g1){
                                                    continue
                                                }
                                                console.log("Box Line Reduction Horizontal", k)
                                                change++;
                                                cellProfile[k].splice(cellProfile[k].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(k),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        //iter through cols per group
                        for (let i=1; i<=3; i++){
                            let g1 = i, g2 = i+3, g3 = i+6;
                            for (let j=1; j<=9; j++){
                                let c = [[0,0,0],[0,0,0],[0,0,0]];
                                for (let k of numberProfile[j]){
                                    if (groups[g1].includes(k) || groups[g2].includes(k) || groups[g3].includes(k)){
                                        let group = Math.ceil(Number(k[1])/3)-1;
                                        let col = Number(k[0]%3)!=0 ? Number(k[0]%3)-1 : 2;
                                        c[col][group]+=1
                                    }
                                }
                                for (let col in c){
                                    let total = c[col].reduce((total, value)=>{return total+value})
                                    let max = c[col].reduce((total, value)=>{return total>value ? total : value})
                                    if (total == max && max > 0){
                                        for (let k of numberProfile[j]){
                                            let group = Math.ceil(Number(k[1])/3)*3-3+Math.ceil(Number(k[0])/3);
                                            let tCol = Number(k[0]);
                                            if ([g1,g2,g3][c[col].indexOf(total)]==group){
                                                if (tCol == g1*3-2+Number(col)){
                                                    continue
                                                }
                                                console.log("Box Line Reduction Vertical", k)
                                                change++;
                                                cellProfile[k].splice(cellProfile[k].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(k),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Box Line Reduction", change]);continue;}
                    }
                    
                    //Rectangle Elimination
                    if (rectElim){
                        for (let i=1; i<=9; i++){
                            for (let hinge of numberProfile[i]){
                                let hGroup = Math.ceil(Number(hinge[1])/3)*3-3+Math.ceil(Number(hinge[0])/3);
                                let colN = numberProfile[i].filter((value)=>{return value[0] == hinge[0] && value != hinge && groups[hGroup].includes(value)==false});
                                let rowN = numberProfile[i].filter((value)=>{return value[1] == hinge[1] && value != hinge && groups[hGroup].includes(value)==false});
                                for (let k=0; k<colN.length; k++){
                                    for (let l=0; l<rowN.length; l++){
                                        let tGroup = Math.ceil(Number(colN[k][1])/3)*3-3+Math.ceil(Number(rowN[l][0])/3);
                                        let checkL = numberProfile[i].filter((value)=>{return groups[tGroup].includes(value)});
                                        let cond = checkL.length > 0;
                                        for (let m of checkL){
                                            if (m[0]!=rowN[l][0] && m[1]!=colN[k][1]){
                                                cond = false;
                                            }
                                        }
                                        if (cond){
                                            let rStr = link(hinge, rowN[l], i)[0];
                                            let cStr = link(hinge, colN[k], i)[0];
                                            if (rStr == true){
                                                console.log("Rectangle Elimination", colN[k], hinge, rowN[l]);
                                                cellProfile[colN[k]].splice(cellProfile[colN[k]].indexOf(i),1);
                                                numberProfile[i].splice(numberProfile[i].indexOf(colN[k]),1);
                                                change++;
                                            }
                                            if (cStr == true){
                                                console.log("Rectangle Elimination", rowN[l], hinge, colN[k]);
                                                cellProfile[rowN[l]].splice(cellProfile[rowN[l]].indexOf(i),1);
                                                numberProfile[i].splice(numberProfile[i].indexOf(rowN[l]),1);
                                                change++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Rectangle Elimination", change]);continue;}
                    }
                    
                    //X-wing
                    if (xWing){
                        for (let cell1 of Object.keys(cellProfile)){
                            for (let j=1; j<=9; j++){
                                if (Number(j)<=Number(cell1[0])){continue;}
                                for (let k=1; k<=9; k++){
                                    if (Number(k)<=Number(cell1[1])){continue;}
                                    let cell2 = `${j}${cell1[1]}`;
                                    if (Object.keys(cellProfile).includes(cell2)==false){continue}
                                    let cell3 = `${cell1[0]}${k}`;
                                    if (Object.keys(cellProfile).includes(cell3)==false){continue}
                                    let cell4 = `${j}${k}`;
                                    if (Object.keys(cellProfile).includes(cell4)==false){continue}
                                    let possibility = []
                                    for (let l=1; l<=9; l++){
                                        if (Object.values(cellProfile[cell1]).includes(l) && Object.values(cellProfile[cell2]).includes(l) && Object.values(cellProfile[cell3]).includes(l) && Object.values(cellProfile[cell4]).includes(l)){
                                            possibility.push(l)
                                        }
                                    }
                                    if (possibility.length == 1){
                                        let conditionRow = true, conditionCol = true;
                                        let n = possibility[0]
                                        for (let l=1; l<=9; l++){
                                            let target = `${l}${cell1[1]}`;
                                            if ([cell1, cell2].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionRow = false;
                                                }
                                            }
                                            target = `${l}${cell3[1]}`;
                                            if ([cell3, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionRow = false;
                                                }
                                            }
                                            target = `${cell1[0]}${l}`;
                                            if ([cell1, cell3].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionCol = false;
                                                }
                                            }
                                            target = `${cell2[0]}${l}`;
                                            if ([cell2, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionCol = false;
                                                }
                                            }
                                        }
                                        if (conditionRow!=conditionCol){
                                            if (conditionRow){
                                                for (let l=1; l<=9; l++){
                                                    let target = `${cell1[0]}${l}`;
                                                    if ([cell1, cell3].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            console.log("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                    target = `${cell2[0]}${l}`;
                                                    if ([cell2, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            console.log("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                            if (conditionCol){
                                                for (let l=1; l<=9; l++){
                                                    let target = `${l}${cell1[1]}`;
                                                    if ([cell1, cell2].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            console.log("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                    target = `${l}${cell3[1]}`;
                                                    if ([cell3, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            console.log("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["X-Wing", change]);continue;}
                    }

                    //Y-wing
                    if (yWing){
                        for (let cell1 of Object.keys(cellProfile)){
                            if (Object.values(cellProfile[cell1]).length!=2){continue;}
                            let group1 = Math.ceil(Number(cell1[1])/3)*3-3+Math.ceil(Number(cell1[0])/3);
                            let checkRow = [...groups[group1]].filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            let checkCol = [...groups[group1]].filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j=1; j<=9; j++){
                                let cell2 = `${j}${cell1[1]}`;
                                if (Object.keys(cellProfile).includes(cell2) && checkRow.includes(cell2)==false){
                                    checkRow.push(cell2);
                                }
                                let cell3 = `${cell1[0]}${j}`;
                                if (Object.keys(cellProfile).includes(cell3) && checkCol.includes(cell3)==false){
                                    checkCol.push(cell3);
                                }
                            }
                            checkRow = checkRow.filter((val)=>{return val!=cell1 && Object.values(cellProfile[val]).length==2 && (Object.values(cellProfile[val])[0]!=Object.values(cellProfile[cell1])[0]||Object.values(cellProfile[val])[1]!=Object.values(cellProfile[cell1])[1])})
                            checkCol = checkCol.filter((val)=>{return val!=cell1 && Object.values(cellProfile[val]).length==2 && (Object.values(cellProfile[val])[0]!=Object.values(cellProfile[cell1])[0]||Object.values(cellProfile[val])[1]!=Object.values(cellProfile[cell1])[1])})
                            for (let cell2 of checkRow){
                                for (let cell3 of checkCol){
                                    if (cell2[0]==cell3[0] || cell2[1]==cell3[1]){continue;}
                                    if (cellProfile[cell2][0]==cellProfile[cell3][0] && cellProfile[cell2][1]==cellProfile[cell3][1]){continue;}
                                    let temp = [...cellProfile[cell1], ...cellProfile[cell2], ...cellProfile[cell3]];
                                    let temp2 = []
                                    temp.forEach((val)=>{if(temp2.includes(val)==false){temp2.push(val)}})
                                    temp2.sort()
                                    if (temp2.length!=3){continue;}
                                    let group2 = Math.ceil(Number(cell2[1])/3)*3-3+Math.ceil(Number(cell2[0])/3);
                                    let group3 = Math.ceil(Number(cell3[1])/3)*3-3+Math.ceil(Number(cell3[0])/3);
                                    if (group2!=group3){
                                        let set2 = [...groups[group2]];
                                        let set3 = [...groups[group3]];
                                        for (let i=1; i<=9; i++){
                                            if (set2.includes(`${cell2[0]}${i}`)==false){set2.push(`${cell2[0]}${i}`)}
                                            if (set2.includes(`${i}${cell2[1]}`)==false){set2.push(`${i}${cell2[1]}`)}
                                            if (set3.includes(`${cell3[0]}${i}`)==false){set3.push(`${cell3[0]}${i}`)}
                                            if (set3.includes(`${i}${cell3[1]}`)==false){set3.push(`${i}${cell3[1]}`)}
                                        }
                                        set2 = set2.filter((val)=>{return Object.keys(cellProfile).includes(val)})
                                        set3 = set3.filter((val)=>{return Object.keys(cellProfile).includes(val)})
                                        let numCheck = temp2.filter((val)=>{return Object.values(cellProfile[cell1]).includes(val)==false})[0]
                                        let setCheck = set2.filter((val)=>{return set3.includes(val) && Object.values(cellProfile[val]).includes(numCheck)})
                                        for (let i of setCheck){
                                            console.log("Y-Wing", i, cellProfile[i], numCheck, [cell1, cell2, cell3], cellProfile[cell1], cellProfile[cell2], cellProfile[cell3]);
                                            cellProfile[i].splice(cellProfile[i].indexOf(numCheck),1);
                                            numberProfile[numCheck].splice(numberProfile[numCheck].indexOf(i),1);
                                            change++;
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Y-Wing", change]);continue;}
                    }

                    //Swordfish
                    if (swordfish){
                        for (let i=1; i<=9; i++){
                            let conG = []
                            for (let j=1; j<=9; j++){
                                let temp = false;
                                for (let k of groups[j].filter((val)=>{return Object.keys(cellProfile).includes(val)})){
                                    if (Object.values(cellProfile[k]).includes(i)){
                                        temp = true;
                                    }
                                }
                                conG.push(temp)
                            }
                            if (conG.reduce((prev, cur)=>{return prev&&cur})){continue}
                            if (numberProfile[i].length>=6){
                                for (let j=1; j<=9; j++){
                                    if (numberProfile[i].filter((val)=>{return val[1] == String(j)}).length<2){continue}
                                    for (let k=j+1; k<=9; k++){
                                        if (numberProfile[i].filter((val)=>{return val[1] == String(k)}).length<2){continue}
                                        for (let l=k+1; l<=9; l++){
                                            if (numberProfile[i].filter((val)=>{return val[1] == String(l)}).length<2){continue}
                                            for (let m=1; m<=9; m++){
                                                if (numberProfile[i].filter((val)=>{return val[0] == String(m)}).length<2){continue}
                                                for (let n=m+1; n<=9; n++){
                                                    if (numberProfile[i].filter((val)=>{return val[0] == String(n)}).length<2){continue}
                                                    for (let o=n+1; o<=9; o++){
                                                        if (numberProfile[i].filter((val)=>{return val[0] == String(o)}).length<2){continue}
                                                        let temp = [[`${m}${j}`, `${n}${j}`, `${o}${j}`], [`${m}${k}`, `${n}${k}`, `${o}${k}`], [`${m}${l}`, `${n}${l}`, `${o}${l}`], [`${m}${j}`, `${m}${k}`, `${m}${l}`], [`${n}${j}`, `${n}${k}`, `${n}${l}`], [`${o}${j}`, `${o}${k}`, `${o}${l}`]];
                                                        let check = []
                                                        let terminator = false;
                                                        for (let p of temp.flat().filter((val)=>{return Object.keys(cellProfile).includes(val)})){
                                                            if (cellProfile[p].includes(i)){
                                                                check.push(p)
                                                            } else {
                                                                terminator = false;
                                                            }
                                                        }
                                                        if (terminator){continue;}
                                                        if (check.length >=6){
                                                            let conCol = true, conRow = true;
                                                            for (let p=1; p<=9; p++){
                                                                if (Object.keys(cellProfile).includes(`${p}${j}`) && numberProfile[i].includes(`${p}${j}`) && check.includes(`${p}${j}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${p}${k}`) && numberProfile[i].includes(`${p}${k}`) && check.includes(`${p}${k}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${p}${l}`) && numberProfile[i].includes(`${p}${l}`) && check.includes(`${p}${l}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${m}${p}`) && numberProfile[i].includes(`${m}${p}`) && check.includes(`${m}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${n}${p}`) && numberProfile[i].includes(`${n}${p}`) && check.includes(`${n}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${o}${p}`) && numberProfile[i].includes(`${o}${p}`) && check.includes(`${o}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (conCol==false && conRow==false){break;}
                                                            }
                                                            if (conCol != conRow){
                                                                if (conRow){
                                                                    for (let p=1; p<=9; p++){
                                                                        if (Object.keys(cellProfile).includes(`${m}${p}`) && numberProfile[i].includes(`${m}${p}`) && check.includes(`${m}${p}`)==false){
                                                                            let target = `${m}${p}`
                                                                            console.log("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${n}${p}`) && numberProfile[i].includes(`${n}${p}`) && check.includes(`${n}${p}`)==false){
                                                                            let target = `${n}${p}`
                                                                            console.log("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${o}${p}`) && numberProfile[i].includes(`${o}${p}`) && check.includes(`${o}${p}`)==false){
                                                                            let target = `${o}${p}`
                                                                            console.log("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                    }
                                                                }
                                                                if (conCol){
                                                                    for (let p=1; p<=9; p++){
                                                                        if (Object.keys(cellProfile).includes(`${p}${j}`) && numberProfile[i].includes(`${p}${j}`) && check.includes(`${p}${j}`)==false){
                                                                            let target = `${p}${j}`
                                                                            console.log("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${p}${k}`) && numberProfile[i].includes(`${p}${k}`) && check.includes(`${p}${k}`)==false){
                                                                            let target = `${p}${k}`
                                                                            console.log("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${p}${l}`) && numberProfile[i].includes(`${p}${l}`) && check.includes(`${p}${l}`)==false){
                                                                            let target = `${p}${l}`
                                                                            console.log("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);  
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Swordfish", change]);continue;}
                    }

                    if (change>0){continue;} else {break;}
                }
                if (true){
                    let state = "Eval";
                    let outputBoard = "";
                    for (let i in cells){
                        outputBoard+=boardLayout[cells[i]];
                    }
                    let groupProfile = new Map();
                    for (let i=1; i<=9; i++){
                        for (let j=0;j<groups[i].length;j++){
                            if (Object.keys(cellProfile).includes(groups[i][j])==true && cellProfile[groups[i][j]].length!=0){
                                groupProfile.set(groups[i][j],cellProfile[groups[i][j]]);
                            }
                        }
                    }
                    for (let i in cells){
                        if(boardLayout[cells[i]]==0){
                            for (let j of groupProfile.entries()){
                                document.getElementById(j[0]).attributes["notes"]["value"]+=j[1];
                                setNotes(j[0], j[1])
                            }
                            state = "Incomplete"
                        }
                    }
                    if (state == "Incomplete"){
                        for (let i in cells){
                            if (boardLayout[cells[i]]==0){
                                state = "Incorrect";
                                //console.log("Incorrect Empty Cell:", cells[i])
                            }
                        }
                    } else {
                        for (let i in cells){
                            if (boardLayout[cells[i]]==0){
                                state = "Incorrect";
                                //console.log("Incorrect Empty Cell:", cells[i])
                            }
                        }
                        for (let i=1; i<=9; i++){
                            let rowNumbers = [], colNumbers = [];
                            for (let j=1; j<=9; j++){
                                let number = boardLayout[`${j}${i}`];
                                if (rowNumbers.includes(number)==false){
                                    rowNumbers.push(number);
                                } else {
                                    state = "Incorrect";
                                    //console.log("Incorrect Row:", `${j}${i}`, number);
                                }
                                number = boardLayout[`${i}${j}`];
                                if (colNumbers.includes(number)==false){
                                    colNumbers.push(number);
                                } else {
                                    state = "Incorrect";
                                    //console.log("Incorrect Col:", `${i}${j}`, number);
                                }
                            }
                        }
                    }
                    if (state == "Eval"){
                        state = "Success";
                    }
                    console.log(state, outputBoard, log, step);
                    document.getElementById("output").value=outputBoard;
                    let c = 0;
                    for (let i of outputBoard){
                        if (i!="0"){c++}
                    }
                    console.log(`${c}/81`)
                    return [state, outputBoard, log, step]
                }
            }
            
            function solver(key){
                const link = (primary, secondary, n)=>{//return array[row/col, group]; key: true (strong link), false (weak link), undefined (no link)
                    if (primary == secondary){return [undefined];}
                    if (Object.values(numberProfile[n]).includes(primary)==false || Object.values(numberProfile[n]).includes(secondary)==false){
                        return [undefined];
                    }
                    let returnVal = [];
                    if (primary[0] == secondary[0]){
                        let strong = true;
                        for (let t=1; t<=9; t++){
                            let check = `${primary[0]}${t}`;
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    } else if (primary[1] == secondary[1]){
                        let strong = true;
                        for (let t=1; t<=9; t++){
                            let check = `${t}${primary[1]}`;
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    }
                    let gPrim = Math.ceil(Number(primary[1])/3)*3-3+Math.ceil(Number(primary[0])/3);
                    let gSec = Math.ceil(Number(secondary[1])/3)*3-3+Math.ceil(Number(secondary[0])/3);
                    if (gPrim == gSec){
                        let strong = true;
                        for (let t of groups[gPrim]){
                            if ([primary, secondary].includes(check) == false && Object.values(numberProfile[n]).includes(check)){
                                strong = false;
                            }
                        }
                        returnVal.push(strong)
                    }
                    return returnVal
                }
                const check = () => {
                    for (let i=1; i<=9; i++){
                        for (let j=1; j<=9; j++){
                            if (boardLayout[`${j}${i}`]==0 && Object.keys(cellProfile).includes(`${j}${i}`)==false && false){
                                return "Incorrect", 1;
                            }
                        }
                    }
                    for (let i=1; i<=9; i++){
                        let rowNumbers = [], colNumbers = [];
                        for (let j=1; j<=9; j++){
                            let number = boardLayout[`${j}${i}`];
                            if (number != 0){
                                if (rowNumbers.includes(number)==false){
                                    rowNumbers.push(number);
                                } else {
                                    return "Incorrect";
                                }
                            }
                            number = boardLayout[`${i}${j}`];
                            if (number != 0){
                                if (colNumbers.includes(number)==false){
                                    colNumbers.push(number);
                                } else {
                                    return "Incorrect";
                                }
                            }
                        }
                    }
                    return "Success"
                    let c = 0;
                }
                
                cellProfile = {}, numberProfile = {1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[]}, boardLayout = {}, snapShot = {};
                for (let i in key.split("")){
                    boardLayout[cells[i]] = Number(key.split("")[i]);
                }
                for (let i of Object.keys(boardLayout)){
                    if (boardLayout[i]==0){
                        cellProfile[i]=[1,2,3,4,5,6,7,8,9];
                    }
                }
                for (let i in cellProfile){
                    for (let j in cellProfile[i]){
                        numberProfile[cellProfile[i][j]] = [numberProfile[cellProfile[i][j]],i].flat().filter((value) => {return value!=undefined});
                    }
                }
                //console.log("Bot Start")
                let change = 0;
                let step = 0;
                let log = [];
                while(true && step<100){
                    if (fill){
                        if (change > 0){
                            let term = false
                            let cellOutput = {}
                            for (let i in cellProfile){//sets tiles for only possible number
                                if (cellProfile[i].length == 1){
                                    //console.log(i, cellProfile[i][0])
                                    boardLayout[i] = cellProfile[i][0];
                                    cellOutput[i] = cellProfile[i][0];
                                    if (numberProfile[cellProfile[i][0]].includes(i)==false){
                                        term = true
                                        break
                                    }
                                    numberProfile[cellProfile[i][0]].splice(numberProfile[cellProfile[i][0]].indexOf(i), 1);
                                    cellProfile[i]=[];
                                }
                            }
                            if (term){break}
                            if (Object.keys(cellOutput).length > 0){
                                log.push(cellOutput)
                                //console.log("Cell Output:", cellOutput);
                            }
                        }
                    }
                    if (change > 0){
                        //console.log(numberProfile); 
                        change=0;
                    }
                    step++;
                    //console.log("Step:", step)
                    lastStep = step - 1
                    for (let i=0; i<1; i++){//removes empty cells from cellProfile
                        let tempObj = {...cellProfile};
                        for (let j in cellProfile){
                            if (cellProfile[j]==[]){
                                delete tempObj[j]
                            }
                        }
                        cellProfile = {...tempObj}
                    }
                    
                    if (true) {
                        let temp = check()
                        if (temp == "Incorrect"){return ["Incorrect", "", log, step]}
                    }
                    
                    for (let i of Object.keys(cellProfile)){//Obvious single
                        let localChange = 0;
                        let values = cellProfile[i];
                        let group = Math.ceil(Number(i[1])/3)*3-3+Math.ceil(Number(i[0])/3);
                        for (let j=1; j<=9; j++){//row
                            let tempValue = boardLayout[`${i[0]}${j}`];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        for (let j=1; j<=9; j++){//col
                            let tempValue = boardLayout[`${j}${i[1]}`];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        for (let j of groups[group].filter((val)=>{return val!=i})){//group
                            let tempValue = boardLayout[j];
                            if (tempValue!=0){
                                if (cellProfile[i].includes(tempValue)){
                                    cellProfile[i].splice(cellProfile[i].indexOf(tempValue), 1);
                                    numberProfile[tempValue].splice(numberProfile[tempValue].indexOf(i), 1);
                                    change++;
                                    localChange++;
                                }
                            }
                        }
                        if (localChange>0){}//console.log("Obvious Single");}
                    }
                    if (change > 0){log.push(["ObvSingle", change]);continue;}
                    

                    //Obvious Pairs
                    if (obviousPair){
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a group
                            let numList = [...groups[i]];
                            for (let j in numList){
                                let cell = numList[j];
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k in numList){
                                        let neighbor = numList[k];
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m in numList){
                                                        let target = numList[m];
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            //console.log(("Obvious Pair Group");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a col
                            for (let j=1; j<=9; j++){
                                let cell = `${i}${j}`;
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k=1; k<=9; k++){
                                        let neighbor = `${i}${k}`;
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m=1; m<=9; m++){
                                                        let target = `${i}${m}`;
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            //console.log(("Obvious Pair Col");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are twins in a row
                            for (let j=1; j<=9; j++){
                                let cell = `${j}${i}`;
                                if (Object.keys(cellProfile).includes(cell)==true && cellProfile[cell].length == 2){
                                    for (let k=1; k<=9; k++){
                                        let neighbor = `${k}${i}`;
                                        if (Object.keys(cellProfile).includes(neighbor)==true && cellProfile[neighbor].length == 2 && Number(cell)<Number(neighbor)){
                                            if (String(cellProfile[cell])==String(cellProfile[neighbor])){
                                                let twins = [cell, neighbor];
                                                let elim = cellProfile[twins[0]];
                                                for (let l in elim){
                                                    for (let m=1; m<=9; m++){
                                                        let target = `${m}${i}`;
                                                        if (twins.includes(target)==false && String(cellProfile[target]).includes(elim[l])){
                                                            //console.log(("Obvious Pair Row");
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(elim[l]),1);
                                                            numberProfile[elim[l]].splice(numberProfile[elim[l]].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvPair", change]);continue;}
                    }
                    
                    //Obvious Triple
                    if (obviousTriple){
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => groups[i].includes(key) && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => groups[i].includes(key))){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                //console.log(("Obvious Triple Group");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0] == i && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => key[0] == i)){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                //console.log(("Obvious Triple Col");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are triples in a row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1] == i && value.length <= 3 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        let n1 = Object.keys(candidates)[j];
                                        let n2 = Object.keys(candidates)[k];
                                        let n3 = Object.keys(candidates)[l];
                                        let temp = [];
                                        let temp2 = [candidates[n1],candidates[n2],candidates[n3]].flat().sort();
                                        temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                        if (temp.length == 3){
                                            let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                            let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                            let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                            if (c1>=2 && c2>=2 && c3>=2){
                                                for (let m of Object.keys(cellProfile).filter((key) => key[1] == i)){
                                                    if ([n1, n2, n3].includes(m)==false){
                                                        for (let n of Object.values(cellProfile[m])){
                                                            if (temp.includes(n)==true){
                                                                //console.log(("Obvious Triple Row");
                                                                change++;
                                                                cellProfile[m].splice(cellProfile[m].indexOf(n),1);
                                                                numberProfile[n].splice(numberProfile[n].indexOf(m),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvTriple", change]);continue;}
                    }
                    
                    //Obvious Quad
                    if (obviousQuad){
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => groups[i].includes(key) && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            //console.log(placeholder, candidates)
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => groups[i].includes(key))){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    //console.log(("Obvious Quad Group");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0] == i && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => key[0] == i)){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    //console.log(("Obvious Quad Col");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//eliminate options if there are quadruples in a row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1] == i && value.length <= 4 && value.length > 1);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            for (let j=0; j<Object.keys(candidates).length; j++){
                                for (let k=j+1; k<Object.keys(candidates).length; k++){
                                    for (let l=k+1; l<Object.keys(candidates).length; l++){
                                        for (let m=l+1; m<Object.keys(candidates).length; m++){
                                            let n1 = Object.keys(candidates)[j];
                                            let n2 = Object.keys(candidates)[k];
                                            let n3 = Object.keys(candidates)[l];
                                            let n4 = Object.keys(candidates)[m];
                                            let temp = [];
                                            let temp2 = [candidates[n1],candidates[n2],candidates[n3],candidates[n4]].flat().sort();
                                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                                            if (temp.length == 4){
                                                let c1 = temp2.lastIndexOf(temp[0]) - temp2.indexOf(temp[0]) + 1;
                                                let c2 = temp2.lastIndexOf(temp[1]) - temp2.indexOf(temp[1]) + 1;
                                                let c3 = temp2.lastIndexOf(temp[2]) - temp2.indexOf(temp[2]) + 1;
                                                let c4 = temp2.lastIndexOf(temp[3]) - temp2.indexOf(temp[3]) + 1;
                                                if (c1>=2 && c2>=2 && c3>=2 && c4>=2){
                                                    for (let n of Object.keys(cellProfile).filter((key) => key[1] == i)){
                                                        if ([n1, n2, n3, n4].includes(n)==false){
                                                            for (let o of Object.values(cellProfile[n])){
                                                                if (temp.includes(o)==true){
                                                                    //console.log(("Obvious Quad Row");
                                                                    change++;
                                                                    cellProfile[n].splice(cellProfile[n].indexOf(o),1);
                                                                    numberProfile[o].splice(numberProfile[o].indexOf(n),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["ObvQuad", change]);continue;}
                    }
                    
                    //Hidden Single
                    if (hiddenSingle){
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in group
                            let group = [...groups[i]];
                            let unfilled = group.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of group.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        //console.log(("Hidden Single Group", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in col
                            let col = [];
                            for (let j=1; j<=9; j++){
                                col.push(`${i}${j}`);
                            }
                            let unfilled = col.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of col.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        //console.log(("Hidden Single Col", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//set for tile with the only number possibilty in row
                            let row = [];
                            for (let j=1; j<=9; j++){
                                row.push(`${j}${i}`);
                            }
                            let unfilled = row.filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j of unfilled){
                                let temp = [];
                                for (let k of row.filter((val)=>{return val!=j})){
                                    if (Object.keys(cellProfile).includes(k)){
                                        temp.push(...cellProfile[k]);
                                    } else {
                                        temp.push(boardLayout[k]);
                                    }
                                }
                                let temp2 = [];
                                for (let k of temp.sort()){
                                    if (temp2.includes(k)==false){
                                        temp2.push(k)
                                    }
                                }
                                for (let k of Object.values(cellProfile[j])){
                                    if (temp2.includes(k)==false){
                                        //console.log(("Hidden Single Row", j, k, cellProfile[j], temp2);
                                        for (let l of Object.values(cellProfile[j]).filter((val)=>{return val!=k})){
                                            numberProfile[l].splice(numberProfile[l].indexOf(j),1);
                                        }
                                        cellProfile[j] = [k];
                                        change++;
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenSingle", change]);continue;}
                    }

                    //Hidden Pairs
                    if (hiddenPair){
                        for (let i=1; i<=9; i++){//group
                            let possibleNum = [];
                            for (let j in groups[i]){
                                if (Object.keys(cellProfile).includes(groups[i][j])==true){
                                    possibleNum.push(cellProfile[groups[i][j]]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l in groups[i]){
                                                for (let m in groups[i]){
                                                    let cell1 = groups[i][l], cell2 = groups[i][m];
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                //console.log(("Hidden Pair Group")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let possibleNum = [];
                            for (let j=1; j<=9; j++){
                                let cell = `${i}${j}`;
                                if (Object.keys(cellProfile).includes(cell)==true){
                                    possibleNum.push(cellProfile[cell]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l=1; l<=9; l++){
                                                for (let m=1; m<=9; m++){
                                                    let cell1 = `${i}${l}`, cell2 = `${i}${m}`;
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                //console.log(("Hidden Pair Row")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let possibleNum = [];
                            for (let j=1; j<=9; j++){
                                let cell = `${j}${i}`;
                                if (Object.keys(cellProfile).includes(cell)==true){
                                    possibleNum.push(cellProfile[cell]);
                                }
                            }
                            possibleNum = possibleNum.flat().sort();
                            for (let j=1; j<=9; j++){
                                for (let k=1; k<=9; k++){
                                    if (j<k){
                                        let amount1 = 0, amount2 = 0;
                                        if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                            amount1 = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                        }
                                        if (possibleNum.lastIndexOf(k)!=-1 && possibleNum.indexOf(k)!=-1){
                                            amount2 = possibleNum.lastIndexOf(k) - possibleNum.indexOf(k) + 1;
                                        }
                                        if (amount1 == 2 && amount2 == 2){
                                            for (let l=1; l<=9; l++){
                                                for (let m=1; m<=9; m++){
                                                    let cell1 = `${l}${i}`, cell2 = `${m}${i}`;
                                                    let empty = Object.keys(cellProfile).includes(cell1) && Object.keys(cellProfile).includes(cell2);
                                                    if(l<m && empty){
                                                        let has1 = Object.values(cellProfile[cell1]).includes(j) && Object.values(cellProfile[cell1]).includes(k);
                                                        let has2 = Object.values(cellProfile[cell2]).includes(j) && Object.values(cellProfile[cell2]).includes(k);
                                                        if(has1 && has2){
                                                            if (String(Object.values(cellProfile[cell1]))!=([j, k]) || String(Object.values(cellProfile[cell2]))!=([j, k])){
                                                                //console.log(("Hidden Pair Col")
                                                                change++;
                                                                cellProfile[cell1] = [j, k];
                                                                cellProfile[cell2] = [j, k];
                                                                for (let m in numberProfile){
                                                                    m = Number(m);
                                                                    if (Object.values(numberProfile[m]).includes(cell1)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell1),1);
                                                                    }
                                                                    if (Object.values(numberProfile[m]).includes(cell2)==true && m!=j && m!=k){
                                                                        numberProfile[m].splice(numberProfile[m].indexOf(cell2),1);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenPair", change]);continue;}
                    }
                    
                    //Hidden Triple
                    if (hiddenTriple){
                        for (let i=1; i<=9; i++){//group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => Object.values(groups[i]).includes(key));
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                //console.log(("Hidden Triple Group");
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                //console.log(("Hidden Triple Col");
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                        let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                        let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                        if (cj>=2 && cj<=3 && ck>=2 && ck<=3 && cl>=2 && cl<=3){
                                            let potential = [];
                                            Object.keys(candidates).forEach((value) => {
                                                if(Object.values(cellProfile[value]).includes(temp[j])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[k])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                                if(Object.values(cellProfile[value]).includes(temp[l])){
                                                    if (potential.includes(value)==false){potential.push(value);}
                                                }
                                            });
                                            if (potential.length == 3){
                                                for (let cell of potential){
                                                    if ((Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[k])) || (Object.values(cellProfile[cell]).includes(temp[j]) && Object.values(cellProfile[cell]).includes(temp[l])) || (Object.values(cellProfile[cell]).includes(temp[k]) && Object.values(cellProfile[cell]).includes(temp[l]))){
                                                        for (let m of Object.values(cellProfile[cell])){
                                                            if ([temp[j],temp[k],temp[l]].includes(m)==false){
                                                                //console.log(("Hidden Triple Row", cell, m, [temp[j],temp[k],temp[l]]);
                                                                change++;
                                                                cellProfile[cell].splice(cellProfile[cell].indexOf(m),1);
                                                                numberProfile[m].splice(numberProfile[m].indexOf(cell),1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenTriple", change]);continue;}
                    }
                    
                    //Hidden Quads
                    if (hiddenQuad){
                        for (let i=1; i<=9; i++){//group
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => Object.values(groups[i]).includes(key));
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    //console.log(("Hidden Quad Group");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//col
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[0]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    //console.log(("Hidden Quad Col");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let i=1; i<=9; i++){//row
                            let placeholder = Object.entries(cellProfile).filter(([key,value]) => key[1]==i);
                            let candidates = {};
                            for (let j in placeholder){
                                candidates[placeholder[j][0]] = placeholder[j][1];
                            }
                            let temp = [];
                            let temp2 = [];
                            for (let cell in candidates){
                                temp2.push(cellProfile[cell])
                            }
                            temp2 = temp2.flat().sort()
                            temp2.forEach((value)=>{if (temp.includes(value)==false){temp.push(value)}});
                            for (let j=0; j<temp.length; j++){
                                for (let k=j+1; k<temp.length; k++){
                                    for (let l=k+1; l<temp.length; l++){
                                        for (let m=l+1; m<temp.length; m++){
                                            let cj = temp2.lastIndexOf(temp[j]) - temp2.indexOf(temp[j]) + 1;
                                            let ck = temp2.lastIndexOf(temp[k]) - temp2.indexOf(temp[k]) + 1;
                                            let cl = temp2.lastIndexOf(temp[l]) - temp2.indexOf(temp[l]) + 1;
                                            let cm = temp2.lastIndexOf(temp[m]) - temp2.indexOf(temp[m]) + 1;
                                            if (cj>=2 && cj<=4 && ck>=2 && ck<=4 && cl>=2 && cl<=4 && cm>=2 && cm<=4){
                                                let potential = [];
                                                Object.keys(candidates).forEach((value) => {
                                                    if(Object.values(cellProfile[value]).includes(temp[j])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[k])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[l])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                    if(Object.values(cellProfile[value]).includes(temp[m])){
                                                        if (potential.includes(value)==false){potential.push(value);}
                                                    }
                                                });
                                                if (potential.length == 4){
                                                    for (let cell of potential){
                                                        let conj = Object.values(cellProfile[cell]).includes(temp[j]);
                                                        let conk = Object.values(cellProfile[cell]).includes(temp[k]);
                                                        let conl = Object.values(cellProfile[cell]).includes(temp[l]);
                                                        let conm = Object.values(cellProfile[cell]).includes(temp[m]);
                                                        if ((conj&&conk)||(conj&&conl)||(conj&&conm)||(conk&&conl)||(conk&&conm)||(conl&&conm)){
                                                            for (let n of Object.values(cellProfile[cell])){
                                                                if ([temp[j],temp[k],temp[l],temp[m]].includes(n)==false){
                                                                    //console.log(("Hidden Quad Col");
                                                                    change++;
                                                                    cellProfile[cell].splice(cellProfile[cell].indexOf(n),1);
                                                                    numberProfile[n].splice(numberProfile[n].indexOf(cell),1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["HiddenQuad", change]);continue;}
                    }
                    
                    //Pointing Pairs & Pointing Triple
                    if (pointingPairTriple){
                        for (let i in groups){
                            let possibleNum = [];
                            let temp = groups[i].filter((val)=>{return Object.keys(cellProfile).includes(val)})
                            for (let j of temp){
                                possibleNum.push(Object.values(cellProfile[j]))
                            }
                            possibleNum = possibleNum.flat().sort();
                            let temp2 = [];
                            for (let j of possibleNum){
                                if (temp2.includes(j)==false){
                                    temp2.push(j)
                                }
                            }
                            for (let j of temp2){
                                let amount = 0;
                                if (possibleNum.lastIndexOf(j)!=-1 && possibleNum.indexOf(j)!=-1){
                                    amount = possibleNum.lastIndexOf(j) - possibleNum.indexOf(j) + 1;
                                }
                                if (amount == 2){
                                    let neighbors = temp.filter((val)=>{return Object.values(cellProfile[val]).includes(j)})
                                    if (neighbors[0][0] == neighbors[1][0]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${neighbors[0][0]}${k}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                //console.log(("Pointing Pair Row");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    } else if (neighbors[0][1] == neighbors[1][1]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${k}${neighbors[0][1]}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                //console.log(("Pointing Pair Col");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    }
                                } else if (amount == 3){
                                    let neighbors = temp.filter((val)=>{return Object.values(cellProfile[val]).includes(j)})
                                    if (neighbors[0][0] == neighbors[1][0] && neighbors[1][0] == neighbors[2][0]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${neighbors[0][0]}${k}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                //console.log(("Pointing Triple Row");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    } else if (neighbors[0][1] == neighbors[1][1] && neighbors[1][1] == neighbors[2][1]){
                                        for (let k=1; k<=9; k++){
                                            let cell = `${k}${neighbors[0][1]}`;
                                            if (Object.keys(cellProfile).includes(cell)==true && neighbors.includes(cell)==false && cellProfile[cell].length!=1 && cellProfile[cell].includes(j)==true){
                                                //console.log(("Pointing Triple Col");
                                                change++;
                                                cellProfile[cell].splice(cellProfile[cell].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(cell),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["PointingPairTriple", change]);continue;}
                    }
                    
                    //Box Line Reduction
                    if (boxLineReduc){
                        //iter through rows per group
                        //for each number, save group & row
                        //for each row, if num of groups == 1: remove other rows in that group
                        for (let i=1; i<9; i+=3){
                            let g1 = i, g2 = i+1, g3 = i+2;
                            for (let j=1; j<=9; j++){
                                let c = [[0,0,0],[0,0,0],[0,0,0]];
                                for (let k of numberProfile[j]){
                                    if (groups[g1].includes(k) || groups[g2].includes(k) || groups[g3].includes(k)){
                                        let group = Math.ceil(Number(k[0])/3)-1;
                                        let row = Number(k[1]%3)!=0 ? Number(k[1]%3)-1 : 2;
                                        c[row][group]+=1
                                    }
                                }
                                for (let row in c){
                                    let total = c[row].reduce((total, value)=>{return total+value})
                                    let max = c[row].reduce((total, value)=>{return total>value ? total : value})
                                    if (total == max && max > 0){
                                        for (let k of Object.values(numberProfile[j])){
                                            let group = Math.ceil(Number(k[1])/3)*3-3+Math.ceil(Number(k[0])/3);
                                            let tRow = Number(k[1]);
                                            if ([g1,g2,g3][c[row].indexOf(total)]==group){
                                                if (tRow == Number(row)+g1){
                                                    continue
                                                }
                                                //console.log("Box Line Reduction Horizontal", k)
                                                change++;
                                                cellProfile[k].splice(cellProfile[k].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(k),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        //iter through cols per group
                        for (let i=1; i<=3; i++){
                            let g1 = i, g2 = i+3, g3 = i+6;
                            for (let j=1; j<=9; j++){
                                let c = [[0,0,0],[0,0,0],[0,0,0]];
                                for (let k of numberProfile[j]){
                                    if (groups[g1].includes(k) || groups[g2].includes(k) || groups[g3].includes(k)){
                                        let group = Math.ceil(Number(k[1])/3)-1;
                                        let col = Number(k[0]%3)!=0 ? Number(k[0]%3)-1 : 2;
                                        c[col][group]+=1
                                    }
                                }
                                for (let col in c){
                                    let total = c[col].reduce((total, value)=>{return total+value})
                                    let max = c[col].reduce((total, value)=>{return total>value ? total : value})
                                    if (total == max && max > 0){
                                        for (let k of Object.values(numberProfile[j])){
                                            let group = Math.ceil(Number(k[1])/3)*3-3+Math.ceil(Number(k[0])/3);
                                            let tCol = Number(k[0]);
                                            if ([g1,g2,g3][c[col].indexOf(total)]==group){
                                                if (tCol == g1*3-2+Number(col)){
                                                    continue
                                                }
                                                //console.log(("Box Line Reduction Vertical", k)
                                                change++;
                                                cellProfile[k].splice(cellProfile[k].indexOf(j),1);
                                                numberProfile[j].splice(numberProfile[j].indexOf(k),1);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Box Line Reduction", change]);continue;}
                    }
                    
                    //Rectangle Elimination
                    if (rectElim){
                        for (let i=1; i<=9; i++){
                            for (let hinge of numberProfile[i]){
                                let hGroup = Math.ceil(Number(hinge[1])/3)*3-3+Math.ceil(Number(hinge[0])/3);
                                let colN = numberProfile[i].filter((value)=>{return value[0] == hinge[0] && value != hinge && groups[hGroup].includes(value)==false});
                                let rowN = numberProfile[i].filter((value)=>{return value[1] == hinge[1] && value != hinge && groups[hGroup].includes(value)==false});
                                for (let k=0; k<colN.length; k++){
                                    for (let l=0; l<rowN.length; l++){
                                        let tGroup = Math.ceil(Number(colN[k][1])/3)*3-3+Math.ceil(Number(rowN[l][0])/3);
                                        let checkL = numberProfile[i].filter((value)=>{return groups[tGroup].includes(value)});
                                        let cond = checkL.length > 0;
                                        for (let m of checkL){
                                            if (m[0]!=rowN[l][0] && m[1]!=colN[k][1]){
                                                cond = false;
                                            }
                                        }
                                        if (cond){
                                            let rStr = link(hinge, rowN[l], i)[0];
                                            let cStr = link(hinge, colN[k], i)[0];
                                            if (rStr == true){
                                                //console.log("Rectangle Elimination", colN[k], hinge, rowN[l]);
                                                cellProfile[colN[k]].splice(cellProfile[colN[k]].indexOf(i),1);
                                                numberProfile[i].splice(numberProfile[i].indexOf(colN[k]),1);
                                                change++;
                                            }
                                            if (cStr == true){
                                                //console.log("Rectangle Elimination", rowN[l], hinge, colN[k]);
                                                cellProfile[rowN[l]].splice(cellProfile[rowN[l]].indexOf(i),1);
                                                numberProfile[i].splice(numberProfile[i].indexOf(rowN[l]),1);
                                                change++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Rectangle Elimination", change]);continue;}
                    }
                    
                    //X-wing
                    if (xWing){
                        for (let cell1 of Object.keys(cellProfile)){
                            for (let j=1; j<=9; j++){
                                if (Number(j)<=Number(cell1[0])){continue;}
                                for (let k=1; k<=9; k++){
                                    if (Number(k)<=Number(cell1[1])){continue;}
                                    let cell2 = `${j}${cell1[1]}`;
                                    if (Object.keys(cellProfile).includes(cell2)==false){continue}
                                    let cell3 = `${cell1[0]}${k}`;
                                    if (Object.keys(cellProfile).includes(cell3)==false){continue}
                                    let cell4 = `${j}${k}`;
                                    if (Object.keys(cellProfile).includes(cell4)==false){continue}
                                    let possibility = []
                                    for (let l=1; l<=9; l++){
                                        if (Object.values(cellProfile[cell1]).includes(l) && Object.values(cellProfile[cell2]).includes(l) && Object.values(cellProfile[cell3]).includes(l) && Object.values(cellProfile[cell4]).includes(l)){
                                            possibility.push(l)
                                        }
                                    }
                                    if (possibility.length == 1){
                                        let conditionRow = true, conditionCol = true;
                                        let n = possibility[0]
                                        for (let l=1; l<=9; l++){
                                            let target = `${l}${cell1[1]}`;
                                            if ([cell1, cell2].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionRow = false;
                                                }
                                            }
                                            target = `${l}${cell3[1]}`;
                                            if ([cell3, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionRow = false;
                                                }
                                            }
                                            target = `${cell1[0]}${l}`;
                                            if ([cell1, cell3].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionCol = false;
                                                }
                                            }
                                            target = `${cell2[0]}${l}`;
                                            if ([cell2, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                if (Object.values(cellProfile[target]).includes(n)){
                                                    conditionCol = false;
                                                }
                                            }
                                        }
                                        if (conditionRow!=conditionCol){
                                            if (conditionRow){
                                                for (let l=1; l<=9; l++){
                                                    let target = `${cell1[0]}${l}`;
                                                    if ([cell1, cell3].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            //console.log(("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                    target = `${cell2[0]}${l}`;
                                                    if ([cell2, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            //console.log(("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                            if (conditionCol){
                                                for (let l=1; l<=9; l++){
                                                    let target = `${l}${cell1[1]}`;
                                                    if ([cell1, cell2].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            //console.log(("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                    target = `${l}${cell3[1]}`;
                                                    if ([cell3, cell4].includes(target)==false && Object.keys(cellProfile).includes(target)){
                                                        if (Object.values(cellProfile[target]).includes(n)){
                                                            //console.log(("X-Wing", target, n)
                                                            change++;
                                                            cellProfile[target].splice(cellProfile[target].indexOf(n), 1);
                                                            numberProfile[n].splice(numberProfile[n].indexOf(target),1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["X-Wing", change]);continue;}
                    }

                    //Y-wing
                    if (yWing){
                        for (let cell1 of Object.keys(cellProfile)){
                            if (Object.values(cellProfile[cell1]).length!=2){continue;}
                            let group1 = Math.ceil(Number(cell1[1])/3)*3-3+Math.ceil(Number(cell1[0])/3);
                            let checkRow = [...groups[group1]].filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            let checkCol = [...groups[group1]].filter((val)=>{return Object.keys(cellProfile).includes(val)});
                            for (let j=1; j<=9; j++){
                                let cell2 = `${j}${cell1[1]}`;
                                if (Object.keys(cellProfile).includes(cell2) && checkRow.includes(cell2)==false){
                                    checkRow.push(cell2);
                                }
                                let cell3 = `${cell1[0]}${j}`;
                                if (Object.keys(cellProfile).includes(cell3) && checkCol.includes(cell3)==false){
                                    checkCol.push(cell3);
                                }
                            }
                            checkRow = checkRow.filter((val)=>{return val!=cell1 && Object.values(cellProfile[val]).length==2 && (Object.values(cellProfile[val])[0]!=Object.values(cellProfile[cell1])[0]||Object.values(cellProfile[val])[1]!=Object.values(cellProfile[cell1])[1])})
                            checkCol = checkCol.filter((val)=>{return val!=cell1 && Object.values(cellProfile[val]).length==2 && (Object.values(cellProfile[val])[0]!=Object.values(cellProfile[cell1])[0]||Object.values(cellProfile[val])[1]!=Object.values(cellProfile[cell1])[1])})
                            for (let cell2 of checkRow){
                                for (let cell3 of checkCol){
                                    if (cell2[0]==cell3[0] || cell2[1]==cell3[1]){continue;}
                                    if (cellProfile[cell2][0]==cellProfile[cell3][0] && cellProfile[cell2][1]==cellProfile[cell3][1]){continue;}
                                    let temp = [...cellProfile[cell1], ...cellProfile[cell2], ...cellProfile[cell3]];
                                    let temp2 = []
                                    temp.forEach((val)=>{if(temp2.includes(val)==false){temp2.push(val)}})
                                    temp2.sort()
                                    if (temp2.length!=3){continue;}
                                    let group2 = Math.ceil(Number(cell2[1])/3)*3-3+Math.ceil(Number(cell2[0])/3);
                                    let group3 = Math.ceil(Number(cell3[1])/3)*3-3+Math.ceil(Number(cell3[0])/3);
                                    if (group2!=group3){
                                        let set2 = [...groups[group2]];
                                        let set3 = [...groups[group3]];
                                        for (let i=1; i<=9; i++){
                                            if (set2.includes(`${cell2[0]}${i}`)==false){set2.push(`${cell2[0]}${i}`)}
                                            if (set2.includes(`${i}${cell2[1]}`)==false){set2.push(`${i}${cell2[1]}`)}
                                            if (set3.includes(`${cell3[0]}${i}`)==false){set3.push(`${cell3[0]}${i}`)}
                                            if (set3.includes(`${i}${cell3[1]}`)==false){set3.push(`${i}${cell3[1]}`)}
                                        }
                                        set2 = set2.filter((val)=>{return Object.keys(cellProfile).includes(val)})
                                        set3 = set3.filter((val)=>{return Object.keys(cellProfile).includes(val)})
                                        let numCheck = temp2.filter((val)=>{return Object.values(cellProfile[cell1]).includes(val)==false})[0]
                                        let setCheck = set2.filter((val)=>{return set3.includes(val) && Object.values(cellProfile[val]).includes(numCheck)})
                                        for (let i of setCheck){
                                            //console.log(("Y-Wing", i, cellProfile[i], numCheck, [cell1, cell2, cell3], cellProfile[cell1], cellProfile[cell2], cellProfile[cell3]);
                                            cellProfile[i].splice(cellProfile[i].indexOf(numCheck),1);
                                            numberProfile[numCheck].splice(numberProfile[numCheck].indexOf(i),1);
                                            change++;
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Y-Wing", change]);continue;}
                    }

                    //Swordfish
                    if (swordfish){
                        for (let i of Object.keys(numberProfile)){
                            let conG = []
                            for (let j=1; j<=9; j++){
                                let temp = false;
                                for (let k of groups[j].filter((val)=>{return Object.keys(cellProfile).includes(val)})){
                                    if (Object.values(cellProfile[k]).includes(i)){
                                        temp = true;
                                    }
                                }
                                conG.push(temp)
                            }
                            if (conG.reduce((prev, cur)=>{return prev&&cur})){continue}
                            if (numberProfile[i].length>=6){
                                for (let j=1; j<=9; j++){
                                    if (numberProfile[i].filter((val)=>{return val[1] == String(j)}).length<2){continue}
                                    for (let k=j+1; k<=9; k++){
                                        if (numberProfile[i].filter((val)=>{return val[1] == String(k)}).length<2){continue}
                                        for (let l=k+1; l<=9; l++){
                                            if (numberProfile[i].filter((val)=>{return val[1] == String(l)}).length<2){continue}
                                            for (let m=1; m<=9; m++){
                                                if (numberProfile[i].filter((val)=>{return val[0] == String(m)}).length<2){continue}
                                                for (let n=m+1; n<=9; n++){
                                                    if (numberProfile[i].filter((val)=>{return val[0] == String(n)}).length<2){continue}
                                                    for (let o=n+1; o<=9; o++){
                                                        if (numberProfile[i].filter((val)=>{return val[0] == String(o)}).length<2){continue}
                                                        let temp = [[`${m}${j}`, `${n}${j}`, `${o}${j}`], [`${m}${k}`, `${n}${k}`, `${o}${k}`], [`${m}${l}`, `${n}${l}`, `${o}${l}`], [`${m}${j}`, `${m}${k}`, `${m}${l}`], [`${n}${j}`, `${n}${k}`, `${n}${l}`], [`${o}${j}`, `${o}${k}`, `${o}${l}`]];
                                                        let check = []
                                                        let terminator = false;
                                                        for (let p of temp.flat().filter((val)=>{return Object.keys(cellProfile).includes(val)})){
                                                            if (cellProfile[p].includes(i)){
                                                                check.push(p)
                                                            } else {
                                                                terminator = false;
                                                            }
                                                        }
                                                        if (terminator){continue;}
                                                        if (check.length >=6){
                                                            let conCol = true, conRow = true;
                                                            for (let p=1; p<=9; p++){
                                                                if (Object.keys(cellProfile).includes(`${p}${j}`) && numberProfile[i].includes(`${p}${j}`) && check.includes(`${p}${j}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${p}${k}`) && numberProfile[i].includes(`${p}${k}`) && check.includes(`${p}${k}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${p}${l}`) && numberProfile[i].includes(`${p}${l}`) && check.includes(`${p}${l}`)==false){
                                                                    conRow = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${m}${p}`) && numberProfile[i].includes(`${m}${p}`) && check.includes(`${m}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${n}${p}`) && numberProfile[i].includes(`${n}${p}`) && check.includes(`${n}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (Object.keys(cellProfile).includes(`${o}${p}`) && numberProfile[i].includes(`${o}${p}`) && check.includes(`${o}${p}`)==false){
                                                                    conCol = false;
                                                                }
                                                                if (conCol==false && conRow==false){break;}
                                                            }
                                                            if (conCol != conRow){
                                                                if (conRow){
                                                                    for (let p=1; p<=9; p++){
                                                                        if (Object.keys(cellProfile).includes(`${m}${p}`) && numberProfile[i].includes(`${m}${p}`) && check.includes(`${m}${p}`)==false){
                                                                            let target = `${m}${p}`
                                                                            //console.log(("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${n}${p}`) && numberProfile[i].includes(`${n}${p}`) && check.includes(`${n}${p}`)==false){
                                                                            let target = `${n}${p}`
                                                                            //console.log(("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${o}${p}`) && numberProfile[i].includes(`${o}${p}`) && check.includes(`${o}${p}`)==false){
                                                                            let target = `${o}${p}`
                                                                            //console.log(("Swordfish Row => Col", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                    }
                                                                }
                                                                if (conCol){
                                                                    for (let p=1; p<=9; p++){
                                                                        if (Object.keys(cellProfile).includes(`${p}${j}`) && numberProfile[i].includes(`${p}${j}`) && check.includes(`${p}${j}`)==false){
                                                                            let target = `${p}${j}`
                                                                            //console.log(("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${p}${k}`) && numberProfile[i].includes(`${p}${k}`) && check.includes(`${p}${k}`)==false){
                                                                            let target = `${p}${k}`
                                                                            //console.log(("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);
                                                                        }
                                                                        if (Object.keys(cellProfile).includes(`${p}${l}`) && numberProfile[i].includes(`${p}${l}`) && check.includes(`${p}${l}`)==false){
                                                                            let target = `${p}${l}`
                                                                            //console.log(("Swordfish Col => Row", target, i)
                                                                            change++;
                                                                            cellProfile[target].splice(cellProfile[target].indexOf(i), 1);
                                                                            numberProfile[i].splice(numberProfile[i].indexOf(target),1);  
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (change > 0){log.push(["Swordfish", change]);continue;}
                    }

                    if (change>0){continue;} else {break;}
                }
                if (true){
                    let state = "Eval";
                    let outputBoard = "";
                    for (let i in cells){
                        outputBoard+=boardLayout[cells[i]];
                    }
                    let groupProfile = new Map();
                    for (let i=1; i<=9; i++){
                        for (let j=0;j<groups[i].length;j++){
                            if (Object.keys(cellProfile).includes(groups[i][j])==true && cellProfile[groups[i][j]].length!=0){
                                groupProfile.set(groups[i][j],cellProfile[groups[i][j]]);
                            }
                        }
                    }
                    for (let i in cells){
                        if(boardLayout[cells[i]]==0){
                            state = "Incomplete"
                        }
                    }
                    if (state == "Incomplete"){
                        for (let i in cells){
                            if (boardLayout[cells[i]]==0){
                                state = "Incorrect";
                                //console.log(("Incorrect Empty Cell:", cells[i])
                            }
                        }
                    } else {
                        for (let i in cells){
                            if (boardLayout[cells[i]]==0){
                                state = "Incorrect";
                                //console.log(("Incorrect Empty Cell:", cells[i])
                            }
                        }
                        for (let i=1; i<=9; i++){
                            let rowNumbers = [], colNumbers = [];
                            for (let j=1; j<=9; j++){
                                let number = boardLayout[`${j}${i}`];
                                if (rowNumbers.includes(number)==false){
                                    rowNumbers.push(number);
                                } else {
                                    state = "Incorrect";
                                    //console.log(("Incorrect Row:", `${j}${i}`, number);
                                }
                                number = boardLayout[`${i}${j}`];
                                if (colNumbers.includes(number)==false){
                                    colNumbers.push(number);
                                } else {
                                    state = "Incorrect";
                                    //console.log(("Incorrect Col:", `${i}${j}`, number);
                                }
                            }
                        }
                    }
                    if (state == "Eval"){
                        state = "Success";
                    }
                    //console.log(state, outputBoard);
                    let c = 0;
                    for (let i of outputBoard){
                        if (i!="0"){c++}
                    }
                    //console.log(`${c}/81`)
                    //if (state=="Success"){console.log(log)}
                    return [state, outputBoard, log, step]
                }
            }

            function randoGenerate(){
                const shuffle = (arr, ref) => {
                    const randShuffle = (arr) => {
                        for (let i=0; i<arr.length*5; i++){
                            if (Math.round(Math.random())==1){
                                let temp = arr[i%arr.length];
                                arr[i%arr.length] = arr[(i+1)%arr.length];
                                arr[(i+1)%arr.length] = temp;
                            }
                        }
                        return arr;
                    }
                    const create = (possible) => {
                        for (let i of possible[0]){
                            for (let j of possible[1]){
                                if ([i].includes(j)){continue}
                                for (let k of possible[2]){
                                    if ([i,j].includes(k)){continue}
                                    for (let l of possible[3]){
                                        if ([i,j,k].includes(l)){continue}
                                        for (let m of possible[4]){
                                            if ([i,j,k,l].includes(m)){continue}
                                            for (let n of possible[5]){
                                                if ([i,j,k,l,m].includes(n)){continue}
                                                for (let o of possible[6]){
                                                    if ([i,j,k,l,m,n].includes(o)){continue}
                                                    for (let p of possible[7]){
                                                        if ([i,j,k,l,m,n,o].includes(p)){continue}
                                                        for (let q of possible[8]){
                                                            if ([i,j,k,l,m,n,o,p].includes(q)){continue}
                                                            return [i,j,k,l,m,n,o,p,q]
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    let possible = []
                    for (let i=0; i<9; i++){
                        let temp = [1,2,3,4,5,6,7,8,9]
                        for (let j=0; j<9; j++){
                            if (ref[j][i]!=0 && temp.includes(ref[j][i])){
                                temp.splice(temp.indexOf(ref[j][i]), 1)
                            } else {
                                break
                            }
                        }
                        possible.push(temp)
                    }
                    for (let i=0; i<9; i++){
                        possible[i] = randShuffle(possible[i])
                    }
                    c = create(possible)
                    return c
                }

                let start = new Date()
                let b = [[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]
                for (let l=0; l<9; l++){
                    while (true){
                        if ((new Date() - start)/1000 > 1){return randoGenerate()}
                        c = shuffle([1,2,3,4,5,6,7,8,9], b)
                        term = true;
                        for (let i=0; i<9; i++){
                            for (let j=0; j<l; j++){
                                if (c[i] == b[j][i]){
                                    term = false
                                }
                            }
                            for (let j=Math.floor(l/3)*3; j<l; j++){
                                if ([b[j][i-i%3+0], b[j][i-i%3+1], b[j][i-i%3+2]].includes(c[i])){
                                    term = false
                                }
                            }
                        }
                        if (term){break}
                    }
                    b[l] = c
                }

                b = b.flat()
                
                console.log((new Date() - start)/1000)

                let mapping = {};
                let count = 0;
                for (let i=1; i<=9; i++){
                    for (let j=1; j<=9; j++){
                        mapping[`${j}${i}`] = count;
                        count++;
                    }
                }
                
                let ans = ""
                for (let i of b){
                    ans+=i
                }

                let s = "Incorrect", output = "", key = "", log = {}, unique = true;
                count = 0;
                start = new Date(), timeLimit = 5;
                override4 = true, override2 = false, override1 = false;
                while (count < 20){//Fancy method
                    break
                    count++
                    if ((new Date() - start)/1000 > timeLimit && override4){console.log((new Date() - start)/1000); override4=false; override2=true}
                    if ((new Date() - start)/1000 > timeLimit*2 && override2){console.log((new Date() - start)/1000); override2=false;override1=true}
                    if ((new Date() - start)/1000 > timeLimit*3 && override1){console.log((new Date() - start)/1000); break}
                    console.log(override4, override2, override1, count)
                    let term = 0
                    if (true){
                        let r1 = Math.floor(Math.random()*9)%9+1;
                        let c1 = Math.floor(Math.random()*9)%9+1;
                        let r2 = 0
                        if (Math.round(Math.random()) && r1!=9 || r1==1){
                            r2 = r1+Math.ceil(Math.random()*(9-r1))%9;
                        } else {
                            r2 = Math.ceil(Math.random()*(r1-1))%9;
                        }
                        let c2 = 0
                        if (Math.round(Math.random()) && c1+Math.abs(r1-r2)<=9 || ((c1+Math.abs(r1-r2)<=9)==true && (c1-Math.abs(r1-r2)>=1)==false)){
                            c2 = c1+Math.abs(r1-r2)
                        } else if (c1-Math.abs(r1-r2)>=1){
                            c2 = c1-Math.abs(r1-r2)
                        }
                        let cell1 = `${c1}${r1}`;
                        let cell4 = `${c2}${r2}`
                        if (cell1!=cell4){
                            if (override4){
                                let cell2 = `${c1}${r2}`
                                let cell3 = `${c2}${r1}`
                                if (b[mapping[cell1]]==0 || b[mapping[cell2]]==0 || b[mapping[cell3]]==0 || b[mapping[cell4]]==0){count--;continue}
                                let hold = [b[mapping[cell1]], b[mapping[cell2]], b[mapping[cell3]], b[mapping[cell4]]]
                                b[mapping[cell1]] = 0;
                                b[mapping[cell2]] = 0;
                                b[mapping[cell3]] = 0;
                                b[mapping[cell4]] = 0;
                                key = ""
                                for (let j of b){
                                    key+=j
                                }
                                let r = solver(key)
                                s = r[0], output = r[1], log = r[2]
                                if (s!="Success" || output!=ans){
                                    b[mapping[cell1]] = hold[0];
                                    b[mapping[cell2]] = hold[1];
                                    b[mapping[cell3]] = hold[2];
                                    b[mapping[cell4]] = hold[3];
                                    count--
                                }
                            }
                            if (override2){
                                if (b[mapping[cell1]]==0 || b[mapping[cell4]]==0){count--;continue}
                                let hold = [b[mapping[cell1]], b[mapping[cell4]]]
                                b[mapping[cell1]] = 0;
                                b[mapping[cell4]] = 0;
                                key = ""
                                for (let j of b){
                                    key+=j
                                }
                                let r = solver(key)
                                s = r[0], output = r[1], log = r[2]
                                if (s!="Success" || output!=ans){
                                    b[mapping[cell1]] = hold[0];
                                    b[mapping[cell4]] = hold[1];
                                    count--
                                }
                            }
                        } 
                        if (override1){
                            if (b[mapping[cell1]]==0){count--;continue}
                            let hold = b[mapping[cell1]]
                            b[mapping[cell1]] = 0;
                            key = ""
                            for (let j of b){
                                key+=j
                            }
                            let r = solver(key)
                            s = r[0], output = r[1], log = r[2]
                            if (s!="Success" || output!=ans){
                                b[mapping[cell1]] = hold;
                                count--;
                            }
                        }
                    }
                }
                while (s!="Success"){//Basic method
                    let term = 0;
                    let i = 0;
                    let limit = 100;
                    let t = new Date()
                    while (true){
                        i++
                        if (i>60){s="Success"; break}
                        term++
                        let rand1 = Math.floor(Math.random()*81)%81;
                        while (b[rand1]==0){
                            rand1 = Math.floor(Math.random()*81)%81;
                        }
                        let rand2 = Math.floor(Math.random()*81)%81;
                        while (rand2==rand1){
                            rand2 = Math.floor(Math.random()*81)%81;
                        }
                        let hold1 = b[rand1];
                        let hold2 = b[rand2];
                        b[rand1] = 0
                        b[rand2] = 0
                        key = ""
                        for (let j of b){
                            key+=j
                        }
                        let r = solver(key)
                        s = r[0], output = r[1], log = r[2]
                        console.log(i, term, s)
                        if (s!="Success"){
                            b[rand1] = hold1;
                            b[rand2] = hold2;
                            //if (term > limit){
                            if ((new Date() - t)/1000 > 5){
                                key = "";
                                for (let j of b){
                                    key+=j;
                                }
                                let r = solver(key)
                                s = r[0], output = r[1], log = r[2]
                                break;
                            }
                            i--
                        } else {
                            t = new Date()
                        }
                    }
                    t=new Date()
                    for (let k in b){
                        if (b[k]==0){continue;}
                        let hold = b[k];
                        b[k] = 0;
                        temp = ""
                        for (let j of b){
                            temp+=j
                        }
                        if (checkUnique(temp)[0]){
                            if (solver(temp)[0]=="Success"){
                                console.log(k)
                                key = temp;
                            } else {
                                b[k] = hold;
                            }
                        } else {
                            b[k] = hold;
                        }
                    }
                    console.log((new Date() - t)/1000)
                    let zero = 0;
                    for (let i of key){
                        if (i==0){
                            zero++
                        }
                    }
                    console.log(term, key, zero)
                }
                while (s!="Success"){//Less Basic Method
                    break
                }
                return [key, output, log, checkUnique(key)[0]]
            }

            function checkUnique(key){
                const solver1 = (key) =>{
                    let b = [];
                    for (let i of key){
                        b.push(Number(i))
                    }
                    let check = true;
                    for (let i=0; i<9; i++){
                        let test1 = [1,2,3,4,5,6,7,8,9];
                        let test2 = [1,2,3,4,5,6,7,8,9];
                        for (let j=0; j<9; j++){
                            if (b[i*9+j]==0){continue}
                            if (test1.includes(b[i*9+j])){
                                test1.splice(test1.indexOf(b[i*9+j]),1)
                            } else {
                                check = false
                            }
                        }
                        for (let j=0; j<9; j++){
                            if (b[j*9+i]==0){continue}
                            if (test2.includes(b[j*9+i])){
                                test2.splice(test2.indexOf(b[j*9+i]),1)
                            } else {
                                check = false
                            }
                        }
                        let g = Math.floor(i/3)*27+i%3*3
                        let test3 = [1,2,3,4,5,6,7,8,9]
                        for (let j=0; j<3; j++){
                            for (let k=0; k<3; k++){
                                if (b[g+j*9+k]==0){continue}
                                if (test3.includes(b[g+j*9+k])){
                                    test3.splice(test3.indexOf(b[g+j*9+k]),1)
                                } else {
                                    check = false
                                }
                            }
                        }
                    }
                    if (check){
                        return ["Success"]
                    } else {
                        return ["Incorrect"]
                    }
                }
                const recurse = (mt, bt, key) =>{
                    if(solutions.length>1){return}
                    while (true){
                        let count = 0
                        for (let i of mt){
                            let iter = [1,2,3,4,5,6,7,8,9]
                            let g = Math.floor(i/27)*27+Math.floor((i%9)/3)*3
                            for (let j=0; j<3; j++){
                                for (let k=0; k<3; k++){
                                    if (g+j+k*9!=i && iter.includes(bt[g+j+k*9])){
                                        iter.splice(iter.indexOf(bt[g+j+k*9]), 1)
                                    }
                                }
                            }
                            for (let j=0; j<9; j++){
                                if (i-i%9+j!=i && iter.includes(bt[i-i%9+j])){
                                    iter.splice(iter.indexOf(bt[i-i%9+j]),1)
                                }
                                if (i%9+9*j!=i && iter.includes(bt[i%9+9*j])){
                                    iter.splice(iter.indexOf(bt[i%9+9*j]),1)
                                }
                            }
                            if (iter.length==1){
                                bt[i] = iter[0]
                                mt.splice(mt.indexOf(i),1)
                                count++
                            }
                            if (iter.length==0){
                                return false
                            }
                        }
                        if (count==0){break}
                    }
                    if (mt.length>0){
                        let iter = [1,2,3,4,5,6,7,8,9]
                        let g = Math.floor(mt[0]/27)*27+Math.floor((mt[0]%9)/3)*3
                        for (let j=0; j<3; j++){
                            for (let k=0; k<3; k++){
                                if (g+j+k*9!=mt[0] && iter.includes(bt[g+j+k*9])){
                                    iter.splice(iter.indexOf(bt[g+j+k*9]), 1)
                                }
                            }
                        }
                        for (let j=0; j<9; j++){
                            if (mt[0]-mt[0]%9+j!=mt[0] && iter.includes(bt[mt[0]-mt[0]%9+j])){
                                iter.splice(iter.indexOf(bt[mt[0]-mt[0]%9+j]),1)
                            }
                            if (mt[0]%9+9*j!=mt[0] && iter.includes(bt[mt[0]%9+9*j])){
                                iter.splice(iter.indexOf(bt[mt[0]%9+9*j]),1)
                            }
                        }
                        for (let j of iter){
                            let copy = [...bt];
                            copy[mt[0]] = j;
                            check = "";
                            for (let k of copy){
                                check+=k
                            }
                            r = solver1(check)
                            s = r[0]
                            if (s=="Success"){
                                mt2 = [...mt]
                                mt2.splice(0,1)
                                a = recurse(mt2, copy, key)
                            }
                        }
                    } else {
                        for (let i=0; i<9; i++){
                            let test1 = [1,2,3,4,5,6,7,8,9];
                            let test2 = [1,2,3,4,5,6,7,8,9];
                            for (let j=0; j<9; j++){
                                if (test1.includes(bt[i*9+j])){
                                    test1.splice(test1.indexOf(bt[i*9+j]),1)
                                }
                                if (test2.includes(bt[j*9+i])){
                                    test2.splice(test2.indexOf(bt[j*9+i]),1)
                                }
                            }
                        }
                        t = ""
                        for (let i of bt){
                            t+=i
                        }
                        solutions.push(t)
                    }
                }
                let b = []
                let map = []
                for (let i in key){
                    b.push(Number(key[i]))
                    if (key[i]=="0") {
                        map.push(Number(i))
                    }
                }
                let solutions = []
                recurse(map, b, key)
                return [solutions.length==1, solutions[0]]
            }

            function loadRandom(){
                console.log("LOAD")
                let key="", ans="", log={}, unique=false;
                while (unique==false){
                    temp = randoGenerate();
                    key = temp[0];
                    ans = temp[1];
                    log = temp[2];
                    unique = temp[3];
                }
                document.getElementById("code").value = key;
                setup()
                document.getElementById("answer").value = ans;
                return [key, output]
            }

            function compare(){
                answer = document.getElementById("answer").value;
                if (answer != "" && answer.length == 81){
                    let returnVal = "Correct";
                    for (let i in cells){
                        let fill = document.getElementById(cells[i]).attributes["content"]["value"];
                        let ans = answer[i];
                        if (fill == ""){
                            if (returnVal=="Correct"){returnVal="Correct, Not Complete"}
                            continue
                            document.getElementById(cells[i]).innerHTML = 0;
                        }
                        if (fill != ans){
                            document.getElementById(cells[i]).style.color = "red";
                            //document.getElementById(cells[i]).innerHTML += `/${ans}`
                            returnVal = "Wrong";
                        }
                    }
                    //console.log(returnVal);
                    return returnVal;
                } else {
                    //console.log("No key / Invalid Key")
                    return "No key / Invalid Key";
                }
            }

            lastStep = 0;
            function snapshot(n=lastStep){
                try {
                    console.log(snapShot[n])
                    console.log(snapShot[n]["key"])
                    /*for (let i of Object.keys(snapShot[n])){
                        click(i);
                        set(0)
                        if (typeof(snapShot[n][i])=="number"){
                            console.log(i, snapShot[n][i])
                            set(snapShot[n][i])
                        }
                    }*/
                } catch {
                    return "no value"
                }
            }

            fill = 1, obviousPair = 1, obviousTriple = 1, obviousQuad = 1, hiddenSingle = 1, hiddenPair = 1, hiddenTriple = 1, hiddenQuad = 1, pointingPairTriple = 1, boxLineReduc = 1, rectElim = 1, xWing = 1, yWing = 1, swordfish = 1, autoCorrect = 1;
            function test(){
                fill                 = 1;
                obviousPair          = 1;
                obviousTriple        = 1;
                obviousQuad          = 1;
                hiddenSingle         = 1;
                hiddenPair           = 1;
                hiddenTriple         = 1;
                hiddenQuad           = 1;
                pointingPairTriple   = 1;
                boxLineReduc         = 1;
                rectElim             = 1;
                xWing                = 1;
                yWing                = 1;
                swordfish            = 1;
                autoCorrect          = 0;
            }
        </script>
    </head>
    <body onload="pageLoad()" onkeydown="keyInput(event)">
        <label for="code">Code: </label><input id="code" value="800000000003600000070090200050007000000045700000100030001000068008500010090000400">
        <br>
        <button onclick="setup()">Load</button>
        <button onclick="loadRandom()">Random</button>
        <button onclick="bot()">Bot</button>
        <!--<button onclick="debugStepped=true;">DebugStepped</button>-->
        <br>
        <table id="board"></table>
        <table id="number">
            <tr>
                <td onclick="set(1)">1</td>
                <td onclick="set(2)">2</td>
                <td onclick="set(3)">3</td>
            </tr>
            <tr>
                <td onclick="set(4)">4</td>
                <td onclick="set(5)">5</td>
                <td onclick="set(6)">6</td>
            </tr>
            <tr>
                <td onclick="set(7)">7</td>
                <td onclick="set(8)">8</td>
                <td onclick="set(9)">9</td>
            </tr>
            <tr>
                <td onclick="set(0)" colspan="3">Erase</td>
            </tr>
            <tr>
                <td id="note" onclick="toggleNote(id)" onmouseenter="hoverNote(id, true)" onmouseleave="hoverNote(id, false)" colspan="3">Note</td>
            </tr>
        </table>
        <label for="output">Output: </label><input id="output" readonly>
        <br>
        <div hidden>
            <input id="answer" value="">
            <button onclick="compare()">Compare</button>
        </div>
    </body>
</html>